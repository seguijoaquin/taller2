<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - src/external/rocksdb/options.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/external/rocksdb</a> - options.h<span style="font-size: 80%;"> (source / <a href="options.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-06-15</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</a>
<span class="lineNum">       2 </span>            : // This source code is licensed under the BSD-style license found in the
<span class="lineNum">       3 </span>            : // LICENSE file in the root directory of this source tree. An additional grant
<span class="lineNum">       4 </span>            : // of patent rights can be found in the PATENTS file in the same directory.
<span class="lineNum">       5 </span>            : // Copyright (c) 2011 The LevelDB Authors. All rights reserved.
<span class="lineNum">       6 </span>            : // Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       7 </span>            : // found in the LICENSE file. See the AUTHORS file for names of contributors.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #ifndef STORAGE_ROCKSDB_INCLUDE_OPTIONS_H_
<span class="lineNum">      10 </span>            : #define STORAGE_ROCKSDB_INCLUDE_OPTIONS_H_
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;string&gt;
<span class="lineNum">      15 </span>            : #include &lt;memory&gt;
<span class="lineNum">      16 </span>            : #include &lt;vector&gt;
<span class="lineNum">      17 </span>            : #include &lt;limits&gt;
<span class="lineNum">      18 </span>            : #include &lt;unordered_map&gt;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;rocksdb/version.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;rocksdb/listener.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;rocksdb/universal_compaction.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #ifdef max
<span class="lineNum">      25 </span>            : #undef max
<span class="lineNum">      26 </span>            : #endif
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : namespace rocksdb {
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : class Cache;
<span class="lineNum">      31 </span>            : class CompactionFilter;
<span class="lineNum">      32 </span>            : class CompactionFilterFactory;
<span class="lineNum">      33 </span>            : class Comparator;
<span class="lineNum">      34 </span>            : class Env;
<span class="lineNum">      35 </span>            : enum InfoLogLevel : unsigned char;
<span class="lineNum">      36 </span>            : class SstFileManager;
<span class="lineNum">      37 </span>            : class FilterPolicy;
<span class="lineNum">      38 </span>            : class Logger;
<span class="lineNum">      39 </span>            : class MergeOperator;
<span class="lineNum">      40 </span>            : class Snapshot;
<span class="lineNum">      41 </span>            : class TableFactory;
<span class="lineNum">      42 </span>            : class MemTableRepFactory;
<span class="lineNum">      43 </span>            : class TablePropertiesCollectorFactory;
<span class="lineNum">      44 </span>            : class RateLimiter;
<span class="lineNum">      45 </span>            : class Slice;
<span class="lineNum">      46 </span>            : class SliceTransform;
<span class="lineNum">      47 </span>            : class Statistics;
<span class="lineNum">      48 </span>            : class InternalKeyComparator;
<span class="lineNum">      49 </span>            : class WalFilter;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // DB contents are stored in a set of blocks, each of which holds a
<span class="lineNum">      52 </span>            : // sequence of key,value pairs.  Each block may be compressed before
<span class="lineNum">      53 </span>            : // being stored in a file.  The following enum describes which
<span class="lineNum">      54 </span>            : // compression method (if any) is used to compress a block.
<span class="lineNum">      55 </span>            : enum CompressionType : char {
<span class="lineNum">      56 </span>            :   // NOTE: do not change the values of existing entries, as these are
<span class="lineNum">      57 </span>            :   // part of the persistent format on disk.
<span class="lineNum">      58 </span>            :   kNoCompression = 0x0,
<span class="lineNum">      59 </span>            :   kSnappyCompression = 0x1,
<span class="lineNum">      60 </span>            :   kZlibCompression = 0x2,
<span class="lineNum">      61 </span>            :   kBZip2Compression = 0x3,
<span class="lineNum">      62 </span>            :   kLZ4Compression = 0x4,
<span class="lineNum">      63 </span>            :   kLZ4HCCompression = 0x5,
<span class="lineNum">      64 </span>            :   // zstd format is not finalized yet so it's subject to changes.
<span class="lineNum">      65 </span>            :   kZSTDNotFinalCompression = 0x40,
<span class="lineNum">      66 </span>            : };
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : enum CompactionStyle : char {
<span class="lineNum">      69 </span>            :   // level based compaction style
<span class="lineNum">      70 </span>            :   kCompactionStyleLevel = 0x0,
<span class="lineNum">      71 </span>            :   // Universal compaction style
<span class="lineNum">      72 </span>            :   // Not supported in ROCKSDB_LITE.
<span class="lineNum">      73 </span>            :   kCompactionStyleUniversal = 0x1,
<span class="lineNum">      74 </span>            :   // FIFO compaction style
<span class="lineNum">      75 </span>            :   // Not supported in ROCKSDB_LITE
<span class="lineNum">      76 </span>            :   kCompactionStyleFIFO = 0x2,
<span class="lineNum">      77 </span>            :   // Disable background compaction. Compaction jobs are submitted
<span class="lineNum">      78 </span>            :   // via CompactFiles().
<span class="lineNum">      79 </span>            :   // Not supported in ROCKSDB_LITE
<span class="lineNum">      80 </span>            :   kCompactionStyleNone = 0x3,
<span class="lineNum">      81 </span>            : };
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : // In Level-based comapction, it Determines which file from a level to be
<span class="lineNum">      84 </span>            : // picked to merge to the next level. We suggest people try
<span class="lineNum">      85 </span>            : // kMinOverlappingRatio first when you tune your database.
<span class="lineNum">      86 </span>            : enum CompactionPri : char {
<span class="lineNum">      87 </span>            :   // Slightly Priotize larger files by size compensated by #deletes
<span class="lineNum">      88 </span>            :   kByCompensatedSize = 0x0,
<span class="lineNum">      89 </span>            :   // First compact files whose data's latest update time is oldest.
<span class="lineNum">      90 </span>            :   // Try this if you only update some hot keys in small ranges.
<span class="lineNum">      91 </span>            :   kOldestLargestSeqFirst = 0x1,
<span class="lineNum">      92 </span>            :   // First compact files whose range hasn't been compacted to the next level
<span class="lineNum">      93 </span>            :   // for the longest. If your updates are random across the key space,
<span class="lineNum">      94 </span>            :   // write amplification is slightly better with this option.
<span class="lineNum">      95 </span>            :   kOldestSmallestSeqFirst = 0x2,
<span class="lineNum">      96 </span>            :   // First compact files whose ratio between overlapping size in next level
<span class="lineNum">      97 </span>            :   // and its size is the smallest. It in many cases can optimize write
<span class="lineNum">      98 </span>            :   // amplification.
<span class="lineNum">      99 </span>            :   kMinOverlappingRatio = 0x3,
<span class="lineNum">     100 </span>            : };
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : enum class WALRecoveryMode : char {
<span class="lineNum">     103 </span>            :   // Original levelDB recovery
<span class="lineNum">     104 </span>            :   // We tolerate incomplete record in trailing data on all logs
<span class="lineNum">     105 </span>            :   // Use case : This is legacy behavior (default)
<span class="lineNum">     106 </span>            :   kTolerateCorruptedTailRecords = 0x00,
<span class="lineNum">     107 </span>            :   // Recover from clean shutdown
<span class="lineNum">     108 </span>            :   // We don't expect to find any corruption in the WAL
<span class="lineNum">     109 </span>            :   // Use case : This is ideal for unit tests and rare applications that
<span class="lineNum">     110 </span>            :   // can require high consistency guarantee
<span class="lineNum">     111 </span>            :   kAbsoluteConsistency = 0x01,
<span class="lineNum">     112 </span>            :   // Recover to point-in-time consistency
<span class="lineNum">     113 </span>            :   // We stop the WAL playback on discovering WAL inconsistency
<span class="lineNum">     114 </span>            :   // Use case : Ideal for systems that have disk controller cache like
<span class="lineNum">     115 </span>            :   // hard disk, SSD without super capacitor that store related data
<span class="lineNum">     116 </span>            :   kPointInTimeRecovery = 0x02,
<span class="lineNum">     117 </span>            :   // Recovery after a disaster
<span class="lineNum">     118 </span>            :   // We ignore any corruption in the WAL and try to salvage as much data as
<span class="lineNum">     119 </span>            :   // possible
<span class="lineNum">     120 </span>            :   // Use case : Ideal for last ditch effort to recover data or systems that
<span class="lineNum">     121 </span>            :   // operate with low grade unrelated data
<span class="lineNum">     122 </span>            :   kSkipAnyCorruptedRecords = 0x03,
<span class="lineNum">     123 </span>            : };
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : struct CompactionOptionsFIFO {
<span class="lineNum">     126 </span>            :   // once the total sum of table files reaches this, we will delete the oldest
<span class="lineNum">     127 </span>            :   // table file
<span class="lineNum">     128 </span>            :   // Default: 1GB
<span class="lineNum">     129 </span>            :   uint64_t max_table_files_size;
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :   CompactionOptionsFIFO() : max_table_files_size(1 * 1024 * 1024 * 1024) {}
<span class="lineNum">     132 </span>            : };
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : // Compression options for different compression algorithms like Zlib
<span class="lineNum">     135 </span>            : struct CompressionOptions {
<span class="lineNum">     136 </span>            :   int window_bits;
<span class="lineNum">     137 </span>            :   int level;
<span class="lineNum">     138 </span>            :   int strategy;
<span class="lineNum">     139 </span>            :   CompressionOptions() : window_bits(-14), level(-1), strategy(0) {}
<span class="lineNum">     140 </span>            :   CompressionOptions(int wbits, int _lev, int _strategy)
<span class="lineNum">     141 </span>            :       : window_bits(wbits), level(_lev), strategy(_strategy) {}
<span class="lineNum">     142 </span>            : };
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : enum UpdateStatus {    // Return status For inplace update callback
<span class="lineNum">     145 </span>            :   UPDATE_FAILED   = 0, // Nothing to update
<span class="lineNum">     146 </span>            :   UPDATED_INPLACE = 1, // Value updated inplace
<span class="lineNum">     147 </span>            :   UPDATED         = 2, // No inplace update. Merged value set
<a name="148"><span class="lineNum">     148 </span>            : };</a>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineCov">        202 : struct DbPath {</span>
<span class="lineNum">     151 </span>            :   std::string path;
<span class="lineNum">     152 </span>            :   uint64_t target_size;  // Target size of total files under the path, in byte.
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   DbPath() : target_size(0) {}
<span class="lineNum">     155 </span>            :   DbPath(const std::string&amp; p, uint64_t t) : path(p), target_size(t) {}
<span class="lineNum">     156 </span>            : };
<span class="lineNum">     157 </span>            : 
<a name="158"><span class="lineNum">     158 </span>            : struct Options;</a>
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span><span class="lineCov">       2424 : struct ColumnFamilyOptions {</span>
<span class="lineNum">     161 </span>            :   // The function recovers options to a previous version. Only 4.6 or later
<span class="lineNum">     162 </span>            :   // versions are supported.
<span class="lineNum">     163 </span>            :   ColumnFamilyOptions* OldDefaults(int rocksdb_major_version = 4,
<span class="lineNum">     164 </span>            :                                    int rocksdb_minor_version = 6);
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :   // Some functions that make it easier to optimize RocksDB
<span class="lineNum">     167 </span>            :   // Use if if your DB is very small (like under 1GB) and you don't want to
<span class="lineNum">     168 </span>            :   // spend lots of memory for memtables.
<span class="lineNum">     169 </span>            :   ColumnFamilyOptions* OptimizeForSmallDb();
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :   // Use this if you don't need to keep the data sorted, i.e. you'll never use
<span class="lineNum">     172 </span>            :   // an iterator, only Put() and Get() API calls
<span class="lineNum">     173 </span>            :   //
<span class="lineNum">     174 </span>            :   // Not supported in ROCKSDB_LITE
<span class="lineNum">     175 </span>            :   ColumnFamilyOptions* OptimizeForPointLookup(
<span class="lineNum">     176 </span>            :       uint64_t block_cache_size_mb);
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :   // Default values for some parameters in ColumnFamilyOptions are not
<span class="lineNum">     179 </span>            :   // optimized for heavy workloads and big datasets, which means you might
<span class="lineNum">     180 </span>            :   // observe write stalls under some conditions. As a starting point for tuning
<span class="lineNum">     181 </span>            :   // RocksDB options, use the following two functions:
<span class="lineNum">     182 </span>            :   // * OptimizeLevelStyleCompaction -- optimizes level style compaction
<span class="lineNum">     183 </span>            :   // * OptimizeUniversalStyleCompaction -- optimizes universal style compaction
<span class="lineNum">     184 </span>            :   // Universal style compaction is focused on reducing Write Amplification
<span class="lineNum">     185 </span>            :   // Factor for big data sets, but increases Space Amplification. You can learn
<span class="lineNum">     186 </span>            :   // more about the different styles here:
<span class="lineNum">     187 </span>            :   // https://github.com/facebook/rocksdb/wiki/Rocksdb-Architecture-Guide
<span class="lineNum">     188 </span>            :   // Make sure to also call IncreaseParallelism(), which will provide the
<span class="lineNum">     189 </span>            :   // biggest performance gains.
<span class="lineNum">     190 </span>            :   // Note: we might use more memory than memtable_memory_budget during high
<span class="lineNum">     191 </span>            :   // write rate period
<span class="lineNum">     192 </span>            :   //
<span class="lineNum">     193 </span>            :   // OptimizeUniversalStyleCompaction is not supported in ROCKSDB_LITE
<span class="lineNum">     194 </span>            :   ColumnFamilyOptions* OptimizeLevelStyleCompaction(
<span class="lineNum">     195 </span>            :       uint64_t memtable_memory_budget = 512 * 1024 * 1024);
<span class="lineNum">     196 </span>            :   ColumnFamilyOptions* OptimizeUniversalStyleCompaction(
<span class="lineNum">     197 </span>            :       uint64_t memtable_memory_budget = 512 * 1024 * 1024);
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   // -------------------
<span class="lineNum">     200 </span>            :   // Parameters that affect behavior
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :   // Comparator used to define the order of keys in the table.
<span class="lineNum">     203 </span>            :   // Default: a comparator that uses lexicographic byte-wise ordering
<span class="lineNum">     204 </span>            :   //
<span class="lineNum">     205 </span>            :   // REQUIRES: The client must ensure that the comparator supplied
<span class="lineNum">     206 </span>            :   // here has the same name and orders keys *exactly* the same as the
<span class="lineNum">     207 </span>            :   // comparator provided to previous open calls on the same DB.
<span class="lineNum">     208 </span>            :   const Comparator* comparator;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :   // REQUIRES: The client must provide a merge operator if Merge operation
<span class="lineNum">     211 </span>            :   // needs to be accessed. Calling Merge on a DB without a merge operator
<span class="lineNum">     212 </span>            :   // would result in Status::NotSupported. The client must ensure that the
<span class="lineNum">     213 </span>            :   // merge operator supplied here has the same name and *exactly* the same
<span class="lineNum">     214 </span>            :   // semantics as the merge operator provided to previous open calls on
<span class="lineNum">     215 </span>            :   // the same DB. The only exception is reserved for upgrade, where a DB
<span class="lineNum">     216 </span>            :   // previously without a merge operator is introduced to Merge operation
<span class="lineNum">     217 </span>            :   // for the first time. It's necessary to specify a merge operator when
<span class="lineNum">     218 </span>            :   // openning the DB in this case.
<span class="lineNum">     219 </span>            :   // Default: nullptr
<span class="lineNum">     220 </span>            :   std::shared_ptr&lt;MergeOperator&gt; merge_operator;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   // A single CompactionFilter instance to call into during compaction.
<span class="lineNum">     223 </span>            :   // Allows an application to modify/delete a key-value during background
<span class="lineNum">     224 </span>            :   // compaction.
<span class="lineNum">     225 </span>            :   //
<span class="lineNum">     226 </span>            :   // If the client requires a new compaction filter to be used for different
<span class="lineNum">     227 </span>            :   // compaction runs, it can specify compaction_filter_factory instead of this
<span class="lineNum">     228 </span>            :   // option.  The client should specify only one of the two.
<span class="lineNum">     229 </span>            :   // compaction_filter takes precedence over compaction_filter_factory if
<span class="lineNum">     230 </span>            :   // client specifies both.
<span class="lineNum">     231 </span>            :   //
<span class="lineNum">     232 </span>            :   // If multithreaded compaction is being used, the supplied CompactionFilter
<span class="lineNum">     233 </span>            :   // instance may be used from different threads concurrently and so should be
<span class="lineNum">     234 </span>            :   // thread-safe.
<span class="lineNum">     235 </span>            :   //
<span class="lineNum">     236 </span>            :   // Default: nullptr
<span class="lineNum">     237 </span>            :   const CompactionFilter* compaction_filter;
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   // This is a factory that provides compaction filter objects which allow
<span class="lineNum">     240 </span>            :   // an application to modify/delete a key-value during background compaction.
<span class="lineNum">     241 </span>            :   //
<span class="lineNum">     242 </span>            :   // A new filter will be created on each compaction run.  If multithreaded
<span class="lineNum">     243 </span>            :   // compaction is being used, each created CompactionFilter will only be used
<span class="lineNum">     244 </span>            :   // from a single thread and so does not need to be thread-safe.
<span class="lineNum">     245 </span>            :   //
<span class="lineNum">     246 </span>            :   // Default: nullptr
<span class="lineNum">     247 </span>            :   std::shared_ptr&lt;CompactionFilterFactory&gt; compaction_filter_factory;
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   // -------------------
<span class="lineNum">     250 </span>            :   // Parameters that affect performance
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   // Amount of data to build up in memory (backed by an unsorted log
<span class="lineNum">     253 </span>            :   // on disk) before converting to a sorted on-disk file.
<span class="lineNum">     254 </span>            :   //
<span class="lineNum">     255 </span>            :   // Larger values increase performance, especially during bulk loads.
<span class="lineNum">     256 </span>            :   // Up to max_write_buffer_number write buffers may be held in memory
<span class="lineNum">     257 </span>            :   // at the same time,
<span class="lineNum">     258 </span>            :   // so you may wish to adjust this parameter to control memory usage.
<span class="lineNum">     259 </span>            :   // Also, a larger write buffer will result in a longer recovery time
<span class="lineNum">     260 </span>            :   // the next time the database is opened.
<span class="lineNum">     261 </span>            :   //
<span class="lineNum">     262 </span>            :   // Note that write_buffer_size is enforced per column family.
<span class="lineNum">     263 </span>            :   // See db_write_buffer_size for sharing memory across column families.
<span class="lineNum">     264 </span>            :   //
<span class="lineNum">     265 </span>            :   // Default: 64MB
<span class="lineNum">     266 </span>            :   //
<span class="lineNum">     267 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     268 </span>            :   size_t write_buffer_size;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   // The maximum number of write buffers that are built up in memory.
<span class="lineNum">     271 </span>            :   // The default and the minimum number is 2, so that when 1 write buffer
<span class="lineNum">     272 </span>            :   // is being flushed to storage, new writes can continue to the other
<span class="lineNum">     273 </span>            :   // write buffer.
<span class="lineNum">     274 </span>            :   // If max_write_buffer_number &gt; 3, writing will be slowed down to
<span class="lineNum">     275 </span>            :   // options.delayed_write_rate if we are writing to the last write buffer
<span class="lineNum">     276 </span>            :   // allowed.
<span class="lineNum">     277 </span>            :   //
<span class="lineNum">     278 </span>            :   // Default: 2
<span class="lineNum">     279 </span>            :   //
<span class="lineNum">     280 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     281 </span>            :   int max_write_buffer_number;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   // The minimum number of write buffers that will be merged together
<span class="lineNum">     284 </span>            :   // before writing to storage.  If set to 1, then
<span class="lineNum">     285 </span>            :   // all write buffers are fushed to L0 as individual files and this increases
<span class="lineNum">     286 </span>            :   // read amplification because a get request has to check in all of these
<span class="lineNum">     287 </span>            :   // files. Also, an in-memory merge may result in writing lesser
<span class="lineNum">     288 </span>            :   // data to storage if there are duplicate records in each of these
<span class="lineNum">     289 </span>            :   // individual write buffers.  Default: 1
<span class="lineNum">     290 </span>            :   int min_write_buffer_number_to_merge;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :   // The total maximum number of write buffers to maintain in memory including
<span class="lineNum">     293 </span>            :   // copies of buffers that have already been flushed.  Unlike
<span class="lineNum">     294 </span>            :   // max_write_buffer_number, this parameter does not affect flushing.
<span class="lineNum">     295 </span>            :   // This controls the minimum amount of write history that will be available
<span class="lineNum">     296 </span>            :   // in memory for conflict checking when Transactions are used.
<span class="lineNum">     297 </span>            :   //
<span class="lineNum">     298 </span>            :   // When using an OptimisticTransactionDB:
<span class="lineNum">     299 </span>            :   // If this value is too low, some transactions may fail at commit time due
<span class="lineNum">     300 </span>            :   // to not being able to determine whether there were any write conflicts.
<span class="lineNum">     301 </span>            :   //
<span class="lineNum">     302 </span>            :   // When using a TransactionDB:
<span class="lineNum">     303 </span>            :   // If Transaction::SetSnapshot is used, TransactionDB will read either
<span class="lineNum">     304 </span>            :   // in-memory write buffers or SST files to do write-conflict checking.
<span class="lineNum">     305 </span>            :   // Increasing this value can reduce the number of reads to SST files
<span class="lineNum">     306 </span>            :   // done for conflict detection.
<span class="lineNum">     307 </span>            :   //
<span class="lineNum">     308 </span>            :   // Setting this value to 0 will cause write buffers to be freed immediately
<span class="lineNum">     309 </span>            :   // after they are flushed.
<span class="lineNum">     310 </span>            :   // If this value is set to -1, 'max_write_buffer_number' will be used.
<span class="lineNum">     311 </span>            :   //
<span class="lineNum">     312 </span>            :   // Default:
<span class="lineNum">     313 </span>            :   // If using a TransactionDB/OptimisticTransactionDB, the default value will
<span class="lineNum">     314 </span>            :   // be set to the value of 'max_write_buffer_number' if it is not explicitly
<span class="lineNum">     315 </span>            :   // set by the user.  Otherwise, the default is 0.
<span class="lineNum">     316 </span>            :   int max_write_buffer_number_to_maintain;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   // Compress blocks using the specified compression algorithm.  This
<span class="lineNum">     319 </span>            :   // parameter can be changed dynamically.
<span class="lineNum">     320 </span>            :   //
<span class="lineNum">     321 </span>            :   // Default: kSnappyCompression, if it's supported. If snappy is not linked
<span class="lineNum">     322 </span>            :   // with the library, the default is kNoCompression.
<span class="lineNum">     323 </span>            :   //
<span class="lineNum">     324 </span>            :   // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
<span class="lineNum">     325 </span>            :   //    ~200-500MB/s compression
<span class="lineNum">     326 </span>            :   //    ~400-800MB/s decompression
<span class="lineNum">     327 </span>            :   // Note that these speeds are significantly faster than most
<span class="lineNum">     328 </span>            :   // persistent storage speeds, and therefore it is typically never
<span class="lineNum">     329 </span>            :   // worth switching to kNoCompression.  Even if the input data is
<span class="lineNum">     330 </span>            :   // incompressible, the kSnappyCompression implementation will
<span class="lineNum">     331 </span>            :   // efficiently detect that and will switch to uncompressed mode.
<span class="lineNum">     332 </span>            :   CompressionType compression;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   // Different levels can have different compression policies. There
<span class="lineNum">     335 </span>            :   // are cases where most lower levels would like to use quick compression
<span class="lineNum">     336 </span>            :   // algorithms while the higher levels (which have more data) use
<span class="lineNum">     337 </span>            :   // compression algorithms that have better compression but could
<span class="lineNum">     338 </span>            :   // be slower. This array, if non-empty, should have an entry for
<span class="lineNum">     339 </span>            :   // each level of the database; these override the value specified in
<span class="lineNum">     340 </span>            :   // the previous field 'compression'.
<span class="lineNum">     341 </span>            :   //
<span class="lineNum">     342 </span>            :   // NOTICE if level_compaction_dynamic_level_bytes=true,
<span class="lineNum">     343 </span>            :   // compression_per_level[0] still determines L0, but other elements
<span class="lineNum">     344 </span>            :   // of the array are based on base level (the level L0 files are merged
<span class="lineNum">     345 </span>            :   // to), and may not match the level users see from info log for metadata.
<span class="lineNum">     346 </span>            :   // If L0 files are merged to level-n, then, for i&gt;0, compression_per_level[i]
<span class="lineNum">     347 </span>            :   // determines compaction type for level n+i-1.
<span class="lineNum">     348 </span>            :   // For example, if we have three 5 levels, and we determine to merge L0
<span class="lineNum">     349 </span>            :   // data to L4 (which means L1..L3 will be empty), then the new files go to
<span class="lineNum">     350 </span>            :   // L4 uses compression type compression_per_level[1].
<span class="lineNum">     351 </span>            :   // If now L0 is merged to L2. Data goes to L2 will be compressed
<span class="lineNum">     352 </span>            :   // according to compression_per_level[1], L3 using compression_per_level[2]
<span class="lineNum">     353 </span>            :   // and L4 using compression_per_level[3]. Compaction for each level can
<span class="lineNum">     354 </span>            :   // change when data grows.
<span class="lineNum">     355 </span>            :   std::vector&lt;CompressionType&gt; compression_per_level;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :   // different options for compression algorithms
<span class="lineNum">     358 </span>            :   CompressionOptions compression_opts;
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :   // If non-nullptr, use the specified function to determine the
<span class="lineNum">     361 </span>            :   // prefixes for keys.  These prefixes will be placed in the filter.
<span class="lineNum">     362 </span>            :   // Depending on the workload, this can reduce the number of read-IOP
<span class="lineNum">     363 </span>            :   // cost for scans when a prefix is passed via ReadOptions to
<span class="lineNum">     364 </span>            :   // db.NewIterator().  For prefix filtering to work properly,
<span class="lineNum">     365 </span>            :   // &quot;prefix_extractor&quot; and &quot;comparator&quot; must be such that the following
<span class="lineNum">     366 </span>            :   // properties hold:
<span class="lineNum">     367 </span>            :   //
<span class="lineNum">     368 </span>            :   // 1) key.starts_with(prefix(key))
<span class="lineNum">     369 </span>            :   // 2) Compare(prefix(key), key) &lt;= 0.
<span class="lineNum">     370 </span>            :   // 3) If Compare(k1, k2) &lt;= 0, then Compare(prefix(k1), prefix(k2)) &lt;= 0
<span class="lineNum">     371 </span>            :   // 4) prefix(prefix(key)) == prefix(key)
<span class="lineNum">     372 </span>            :   //
<span class="lineNum">     373 </span>            :   // Default: nullptr
<span class="lineNum">     374 </span>            :   std::shared_ptr&lt;const SliceTransform&gt; prefix_extractor;
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   // Number of levels for this database
<span class="lineNum">     377 </span>            :   int num_levels;
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   // Number of files to trigger level-0 compaction. A value &lt;0 means that
<span class="lineNum">     380 </span>            :   // level-0 compaction will not be triggered by number of files at all.
<span class="lineNum">     381 </span>            :   //
<span class="lineNum">     382 </span>            :   // Default: 4
<span class="lineNum">     383 </span>            :   //
<span class="lineNum">     384 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     385 </span>            :   int level0_file_num_compaction_trigger;
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :   // Soft limit on number of level-0 files. We start slowing down writes at this
<span class="lineNum">     388 </span>            :   // point. A value &lt;0 means that no writing slow down will be triggered by
<span class="lineNum">     389 </span>            :   // number of files in level-0.
<span class="lineNum">     390 </span>            :   //
<span class="lineNum">     391 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     392 </span>            :   int level0_slowdown_writes_trigger;
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   // Maximum number of level-0 files.  We stop writes at this point.
<span class="lineNum">     395 </span>            :   //
<span class="lineNum">     396 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     397 </span>            :   int level0_stop_writes_trigger;
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   // This does not do anything anymore. Deprecated.
<span class="lineNum">     400 </span>            :   int max_mem_compaction_level;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   // Target file size for compaction.
<span class="lineNum">     403 </span>            :   // target_file_size_base is per-file size for level-1.
<span class="lineNum">     404 </span>            :   // Target file size for level L can be calculated by
<span class="lineNum">     405 </span>            :   // target_file_size_base * (target_file_size_multiplier ^ (L-1))
<span class="lineNum">     406 </span>            :   // For example, if target_file_size_base is 2MB and
<span class="lineNum">     407 </span>            :   // target_file_size_multiplier is 10, then each file on level-1 will
<span class="lineNum">     408 </span>            :   // be 2MB, and each file on level 2 will be 20MB,
<span class="lineNum">     409 </span>            :   // and each file on level-3 will be 200MB.
<span class="lineNum">     410 </span>            :   //
<span class="lineNum">     411 </span>            :   // Default: 64MB.
<span class="lineNum">     412 </span>            :   //
<span class="lineNum">     413 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     414 </span>            :   uint64_t target_file_size_base;
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :   // By default target_file_size_multiplier is 1, which means
<span class="lineNum">     417 </span>            :   // by default files in different levels will have similar size.
<span class="lineNum">     418 </span>            :   //
<span class="lineNum">     419 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     420 </span>            :   int target_file_size_multiplier;
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   // Control maximum total data size for a level.
<span class="lineNum">     423 </span>            :   // max_bytes_for_level_base is the max total for level-1.
<span class="lineNum">     424 </span>            :   // Maximum number of bytes for level L can be calculated as
<span class="lineNum">     425 </span>            :   // (max_bytes_for_level_base) * (max_bytes_for_level_multiplier ^ (L-1))
<span class="lineNum">     426 </span>            :   // For example, if max_bytes_for_level_base is 200MB, and if
<span class="lineNum">     427 </span>            :   // max_bytes_for_level_multiplier is 10, total data size for level-1
<span class="lineNum">     428 </span>            :   // will be 2GB, total file size for level-2 will be 20GB,
<span class="lineNum">     429 </span>            :   // and total file size for level-3 will be 200GB.
<span class="lineNum">     430 </span>            :   //
<span class="lineNum">     431 </span>            :   // Default: 256MB.
<span class="lineNum">     432 </span>            :   //
<span class="lineNum">     433 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     434 </span>            :   uint64_t max_bytes_for_level_base;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   // If true, RocksDB will pick target size of each level dynamically.
<span class="lineNum">     437 </span>            :   // We will pick a base level b &gt;= 1. L0 will be directly merged into level b,
<span class="lineNum">     438 </span>            :   // instead of always into level 1. Level 1 to b-1 need to be empty.
<span class="lineNum">     439 </span>            :   // We try to pick b and its target size so that
<span class="lineNum">     440 </span>            :   // 1. target size is in the range of
<span class="lineNum">     441 </span>            :   //   (max_bytes_for_level_base / max_bytes_for_level_multiplier,
<span class="lineNum">     442 </span>            :   //    max_bytes_for_level_base]
<span class="lineNum">     443 </span>            :   // 2. target size of the last level (level num_levels-1) equals to extra size
<span class="lineNum">     444 </span>            :   //    of the level.
<span class="lineNum">     445 </span>            :   // At the same time max_bytes_for_level_multiplier and
<span class="lineNum">     446 </span>            :   // max_bytes_for_level_multiplier_additional are still satisfied.
<span class="lineNum">     447 </span>            :   //
<span class="lineNum">     448 </span>            :   // With this option on, from an empty DB, we make last level the base level,
<span class="lineNum">     449 </span>            :   // which means merging L0 data into the last level, until it exceeds
<span class="lineNum">     450 </span>            :   // max_bytes_for_level_base. And then we make the second last level to be
<span class="lineNum">     451 </span>            :   // base level, to start to merge L0 data to second last level, with its
<span class="lineNum">     452 </span>            :   // target size to be 1/max_bytes_for_level_multiplier of the last level's
<span class="lineNum">     453 </span>            :   // extra size. After the data accumulates more so that we need to move the
<span class="lineNum">     454 </span>            :   // base level to the third last one, and so on.
<span class="lineNum">     455 </span>            :   //
<span class="lineNum">     456 </span>            :   // For example, assume max_bytes_for_level_multiplier=10, num_levels=6,
<span class="lineNum">     457 </span>            :   // and max_bytes_for_level_base=10MB.
<span class="lineNum">     458 </span>            :   // Target sizes of level 1 to 5 starts with:
<span class="lineNum">     459 </span>            :   // [- - - - 10MB]
<span class="lineNum">     460 </span>            :   // with base level is level. Target sizes of level 1 to 4 are not applicable
<span class="lineNum">     461 </span>            :   // because they will not be used.
<span class="lineNum">     462 </span>            :   // Until the size of Level 5 grows to more than 10MB, say 11MB, we make
<span class="lineNum">     463 </span>            :   // base target to level 4 and now the targets looks like:
<span class="lineNum">     464 </span>            :   // [- - - 1.1MB 11MB]
<span class="lineNum">     465 </span>            :   // While data are accumulated, size targets are tuned based on actual data
<span class="lineNum">     466 </span>            :   // of level 5. When level 5 has 50MB of data, the target is like:
<span class="lineNum">     467 </span>            :   // [- - - 5MB 50MB]
<span class="lineNum">     468 </span>            :   // Until level 5's actual size is more than 100MB, say 101MB. Now if we keep
<span class="lineNum">     469 </span>            :   // level 4 to be the base level, its target size needs to be 10.1MB, which
<span class="lineNum">     470 </span>            :   // doesn't satisfy the target size range. So now we make level 3 the target
<span class="lineNum">     471 </span>            :   // size and the target sizes of the levels look like:
<span class="lineNum">     472 </span>            :   // [- - 1.01MB 10.1MB 101MB]
<span class="lineNum">     473 </span>            :   // In the same way, while level 5 further grows, all levels' targets grow,
<span class="lineNum">     474 </span>            :   // like
<span class="lineNum">     475 </span>            :   // [- - 5MB 50MB 500MB]
<span class="lineNum">     476 </span>            :   // Until level 5 exceeds 1000MB and becomes 1001MB, we make level 2 the
<span class="lineNum">     477 </span>            :   // base level and make levels' target sizes like this:
<span class="lineNum">     478 </span>            :   // [- 1.001MB 10.01MB 100.1MB 1001MB]
<span class="lineNum">     479 </span>            :   // and go on...
<span class="lineNum">     480 </span>            :   //
<span class="lineNum">     481 </span>            :   // By doing it, we give max_bytes_for_level_multiplier a priority against
<span class="lineNum">     482 </span>            :   // max_bytes_for_level_base, for a more predictable LSM tree shape. It is
<span class="lineNum">     483 </span>            :   // useful to limit worse case space amplification.
<span class="lineNum">     484 </span>            :   //
<span class="lineNum">     485 </span>            :   // max_bytes_for_level_multiplier_additional is ignored with this flag on.
<span class="lineNum">     486 </span>            :   //
<span class="lineNum">     487 </span>            :   // Turning this feature on or off for an existing DB can cause unexpected
<span class="lineNum">     488 </span>            :   // LSM tree structure so it's not recommended.
<span class="lineNum">     489 </span>            :   //
<span class="lineNum">     490 </span>            :   // NOTE: this option is experimental
<span class="lineNum">     491 </span>            :   //
<span class="lineNum">     492 </span>            :   // Default: false
<span class="lineNum">     493 </span>            :   bool level_compaction_dynamic_level_bytes;
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :   // Default: 10.
<span class="lineNum">     496 </span>            :   //
<span class="lineNum">     497 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     498 </span>            :   int max_bytes_for_level_multiplier;
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   // Different max-size multipliers for different levels.
<span class="lineNum">     501 </span>            :   // These are multiplied by max_bytes_for_level_multiplier to arrive
<span class="lineNum">     502 </span>            :   // at the max-size of each level.
<span class="lineNum">     503 </span>            :   //
<span class="lineNum">     504 </span>            :   // Default: 1
<span class="lineNum">     505 </span>            :   //
<span class="lineNum">     506 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     507 </span>            :   std::vector&lt;int&gt; max_bytes_for_level_multiplier_additional;
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :   // Maximum number of bytes in all compacted files.  We avoid expanding
<span class="lineNum">     510 </span>            :   // the lower level file set of a compaction if it would make the
<span class="lineNum">     511 </span>            :   // total compaction cover more than
<span class="lineNum">     512 </span>            :   // (expanded_compaction_factor * targetFileSizeLevel()) many bytes.
<span class="lineNum">     513 </span>            :   //
<span class="lineNum">     514 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     515 </span>            :   int expanded_compaction_factor;
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :   // Maximum number of bytes in all source files to be compacted in a
<span class="lineNum">     518 </span>            :   // single compaction run. We avoid picking too many files in the
<span class="lineNum">     519 </span>            :   // source level so that we do not exceed the total source bytes
<span class="lineNum">     520 </span>            :   // for compaction to exceed
<span class="lineNum">     521 </span>            :   // (source_compaction_factor * targetFileSizeLevel()) many bytes.
<span class="lineNum">     522 </span>            :   // Default:1, i.e. pick maxfilesize amount of data as the source of
<span class="lineNum">     523 </span>            :   // a compaction.
<span class="lineNum">     524 </span>            :   //
<span class="lineNum">     525 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     526 </span>            :   int source_compaction_factor;
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :   // Control maximum bytes of overlaps in grandparent (i.e., level+2) before we
<span class="lineNum">     529 </span>            :   // stop building a single file in a level-&gt;level+1 compaction.
<span class="lineNum">     530 </span>            :   //
<span class="lineNum">     531 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     532 </span>            :   int max_grandparent_overlap_factor;
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   // DEPRECATED -- this options is no longer used
<span class="lineNum">     535 </span>            :   // Puts are delayed to options.delayed_write_rate when any level has a
<span class="lineNum">     536 </span>            :   // compaction score that exceeds soft_rate_limit. This is ignored when == 0.0.
<span class="lineNum">     537 </span>            :   //
<span class="lineNum">     538 </span>            :   // Default: 0 (disabled)
<span class="lineNum">     539 </span>            :   //
<span class="lineNum">     540 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     541 </span>            :   double soft_rate_limit;
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   // DEPRECATED -- this options is no longer used
<span class="lineNum">     544 </span>            :   double hard_rate_limit;
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   // All writes will be slowed down to at least delayed_write_rate if estimated
<span class="lineNum">     547 </span>            :   // bytes needed to be compaction exceed this threshold.
<span class="lineNum">     548 </span>            :   //
<span class="lineNum">     549 </span>            :   // Default: 64GB
<span class="lineNum">     550 </span>            :   uint64_t soft_pending_compaction_bytes_limit;
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :   // All writes are stopped if estimated bytes needed to be compaction exceed
<span class="lineNum">     553 </span>            :   // this threshold.
<span class="lineNum">     554 </span>            :   //
<span class="lineNum">     555 </span>            :   // Default: 256GB
<span class="lineNum">     556 </span>            :   uint64_t hard_pending_compaction_bytes_limit;
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :   // DEPRECATED -- this options is no longer used
<span class="lineNum">     559 </span>            :   unsigned int rate_limit_delay_max_milliseconds;
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :   // size of one block in arena memory allocation.
<span class="lineNum">     562 </span>            :   // If &lt;= 0, a proper value is automatically calculated (usually 1/8 of
<span class="lineNum">     563 </span>            :   // writer_buffer_size, rounded up to a multiple of 4KB).
<span class="lineNum">     564 </span>            :   //
<span class="lineNum">     565 </span>            :   // There are two additional restriction of the The specified size:
<span class="lineNum">     566 </span>            :   // (1) size should be in the range of [4096, 2 &lt;&lt; 30] and
<span class="lineNum">     567 </span>            :   // (2) be the multiple of the CPU word (which helps with the memory
<span class="lineNum">     568 </span>            :   // alignment).
<span class="lineNum">     569 </span>            :   //
<span class="lineNum">     570 </span>            :   // We'll automatically check and adjust the size number to make sure it
<span class="lineNum">     571 </span>            :   // conforms to the restrictions.
<span class="lineNum">     572 </span>            :   //
<span class="lineNum">     573 </span>            :   // Default: 0
<span class="lineNum">     574 </span>            :   //
<span class="lineNum">     575 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     576 </span>            :   size_t arena_block_size;
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   // Disable automatic compactions. Manual compactions can still
<span class="lineNum">     579 </span>            :   // be issued on this column family
<span class="lineNum">     580 </span>            :   //
<span class="lineNum">     581 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     582 </span>            :   bool disable_auto_compactions;
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :   // DEPREACTED
<span class="lineNum">     585 </span>            :   // Does not have any effect.
<span class="lineNum">     586 </span>            :   bool purge_redundant_kvs_while_flush;
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :   // The compaction style. Default: kCompactionStyleLevel
<span class="lineNum">     589 </span>            :   CompactionStyle compaction_style;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   // If level compaction_style = kCompactionStyleLevel, for each level,
<span class="lineNum">     592 </span>            :   // which files are prioritized to be picked to compact.
<span class="lineNum">     593 </span>            :   // Default: kCompactionPriByCompensatedSize
<span class="lineNum">     594 </span>            :   CompactionPri compaction_pri;
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :   // If true, compaction will verify checksum on every read that happens
<span class="lineNum">     597 </span>            :   // as part of compaction
<span class="lineNum">     598 </span>            :   //
<span class="lineNum">     599 </span>            :   // Default: true
<span class="lineNum">     600 </span>            :   //
<span class="lineNum">     601 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     602 </span>            :   bool verify_checksums_in_compaction;
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   // The options needed to support Universal Style compactions
<span class="lineNum">     605 </span>            :   CompactionOptionsUniversal compaction_options_universal;
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :   // The options for FIFO compaction style
<span class="lineNum">     608 </span>            :   CompactionOptionsFIFO compaction_options_fifo;
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            :   // Use KeyMayExist API to filter deletes when this is true.
<span class="lineNum">     611 </span>            :   // If KeyMayExist returns false, i.e. the key definitely does not exist, then
<span class="lineNum">     612 </span>            :   // the delete is a noop. KeyMayExist only incurs in-memory look up.
<span class="lineNum">     613 </span>            :   // This optimization avoids writing the delete to storage when appropriate.
<span class="lineNum">     614 </span>            :   //
<span class="lineNum">     615 </span>            :   // Default: false
<span class="lineNum">     616 </span>            :   //
<span class="lineNum">     617 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     618 </span>            :   bool filter_deletes;
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :   // An iteration-&gt;Next() sequentially skips over keys with the same
<span class="lineNum">     621 </span>            :   // user-key unless this option is set. This number specifies the number
<span class="lineNum">     622 </span>            :   // of keys (with the same userkey) that will be sequentially
<span class="lineNum">     623 </span>            :   // skipped before a reseek is issued.
<span class="lineNum">     624 </span>            :   //
<span class="lineNum">     625 </span>            :   // Default: 8
<span class="lineNum">     626 </span>            :   //
<span class="lineNum">     627 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     628 </span>            :   uint64_t max_sequential_skip_in_iterations;
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :   // This is a factory that provides MemTableRep objects.
<span class="lineNum">     631 </span>            :   // Default: a factory that provides a skip-list-based implementation of
<span class="lineNum">     632 </span>            :   // MemTableRep.
<span class="lineNum">     633 </span>            :   std::shared_ptr&lt;MemTableRepFactory&gt; memtable_factory;
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :   // This is a factory that provides TableFactory objects.
<span class="lineNum">     636 </span>            :   // Default: a block-based table factory that provides a default
<span class="lineNum">     637 </span>            :   // implementation of TableBuilder and TableReader with default
<span class="lineNum">     638 </span>            :   // BlockBasedTableOptions.
<span class="lineNum">     639 </span>            :   std::shared_ptr&lt;TableFactory&gt; table_factory;
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :   // Block-based table related options are moved to BlockBasedTableOptions.
<span class="lineNum">     642 </span>            :   // Related options that were originally here but now moved include:
<span class="lineNum">     643 </span>            :   //   no_block_cache
<span class="lineNum">     644 </span>            :   //   block_cache
<span class="lineNum">     645 </span>            :   //   block_cache_compressed
<span class="lineNum">     646 </span>            :   //   block_size
<span class="lineNum">     647 </span>            :   //   block_size_deviation
<span class="lineNum">     648 </span>            :   //   block_restart_interval
<span class="lineNum">     649 </span>            :   //   filter_policy
<span class="lineNum">     650 </span>            :   //   whole_key_filtering
<span class="lineNum">     651 </span>            :   // If you'd like to customize some of these options, you will need to
<span class="lineNum">     652 </span>            :   // use NewBlockBasedTableFactory() to construct a new table factory.
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :   // This option allows user to to collect their own interested statistics of
<span class="lineNum">     655 </span>            :   // the tables.
<span class="lineNum">     656 </span>            :   // Default: empty vector -- no user-defined statistics collection will be
<span class="lineNum">     657 </span>            :   // performed.
<span class="lineNum">     658 </span>            :   typedef std::vector&lt;std::shared_ptr&lt;TablePropertiesCollectorFactory&gt;&gt;
<span class="lineNum">     659 </span>            :       TablePropertiesCollectorFactories;
<span class="lineNum">     660 </span>            :   TablePropertiesCollectorFactories table_properties_collector_factories;
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   // Allows thread-safe inplace updates. If this is true, there is no way to
<span class="lineNum">     663 </span>            :   // achieve point-in-time consistency using snapshot or iterator (assuming
<span class="lineNum">     664 </span>            :   // concurrent updates). Hence iterator and multi-get will return results
<span class="lineNum">     665 </span>            :   // which are not consistent as of any point-in-time.
<span class="lineNum">     666 </span>            :   // If inplace_callback function is not set,
<span class="lineNum">     667 </span>            :   //   Put(key, new_value) will update inplace the existing_value iff
<span class="lineNum">     668 </span>            :   //   * key exists in current memtable
<span class="lineNum">     669 </span>            :   //   * new sizeof(new_value) &lt;= sizeof(existing_value)
<span class="lineNum">     670 </span>            :   //   * existing_value for that key is a put i.e. kTypeValue
<span class="lineNum">     671 </span>            :   // If inplace_callback function is set, check doc for inplace_callback.
<span class="lineNum">     672 </span>            :   // Default: false.
<span class="lineNum">     673 </span>            :   bool inplace_update_support;
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :   // Number of locks used for inplace update
<span class="lineNum">     676 </span>            :   // Default: 10000, if inplace_update_support = true, else 0.
<span class="lineNum">     677 </span>            :   //
<span class="lineNum">     678 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     679 </span>            :   size_t inplace_update_num_locks;
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            :   // existing_value - pointer to previous value (from both memtable and sst).
<span class="lineNum">     682 </span>            :   //                  nullptr if key doesn't exist
<span class="lineNum">     683 </span>            :   // existing_value_size - pointer to size of existing_value).
<span class="lineNum">     684 </span>            :   //                       nullptr if key doesn't exist
<span class="lineNum">     685 </span>            :   // delta_value - Delta value to be merged with the existing_value.
<span class="lineNum">     686 </span>            :   //               Stored in transaction logs.
<span class="lineNum">     687 </span>            :   // merged_value - Set when delta is applied on the previous value.
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :   // Applicable only when inplace_update_support is true,
<span class="lineNum">     690 </span>            :   // this callback function is called at the time of updating the memtable
<span class="lineNum">     691 </span>            :   // as part of a Put operation, lets say Put(key, delta_value). It allows the
<span class="lineNum">     692 </span>            :   // 'delta_value' specified as part of the Put operation to be merged with
<span class="lineNum">     693 </span>            :   // an 'existing_value' of the key in the database.
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   // If the merged value is smaller in size that the 'existing_value',
<span class="lineNum">     696 </span>            :   // then this function can update the 'existing_value' buffer inplace and
<span class="lineNum">     697 </span>            :   // the corresponding 'existing_value'_size pointer, if it wishes to.
<span class="lineNum">     698 </span>            :   // The callback should return UpdateStatus::UPDATED_INPLACE.
<span class="lineNum">     699 </span>            :   // In this case. (In this case, the snapshot-semantics of the rocksdb
<span class="lineNum">     700 </span>            :   // Iterator is not atomic anymore).
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :   // If the merged value is larger in size than the 'existing_value' or the
<span class="lineNum">     703 </span>            :   // application does not wish to modify the 'existing_value' buffer inplace,
<span class="lineNum">     704 </span>            :   // then the merged value should be returned via *merge_value. It is set by
<span class="lineNum">     705 </span>            :   // merging the 'existing_value' and the Put 'delta_value'. The callback should
<span class="lineNum">     706 </span>            :   // return UpdateStatus::UPDATED in this case. This merged value will be added
<span class="lineNum">     707 </span>            :   // to the memtable.
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :   // If merging fails or the application does not wish to take any action,
<span class="lineNum">     710 </span>            :   // then the callback should return UpdateStatus::UPDATE_FAILED.
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :   // Please remember that the original call from the application is Put(key,
<span class="lineNum">     713 </span>            :   // delta_value). So the transaction log (if enabled) will still contain (key,
<span class="lineNum">     714 </span>            :   // delta_value). The 'merged_value' is not stored in the transaction log.
<span class="lineNum">     715 </span>            :   // Hence the inplace_callback function should be consistent across db reopens.
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :   // Default: nullptr
<span class="lineNum">     718 </span>            :   UpdateStatus (*inplace_callback)(char* existing_value,
<span class="lineNum">     719 </span>            :                                    uint32_t* existing_value_size,
<span class="lineNum">     720 </span>            :                                    Slice delta_value,
<span class="lineNum">     721 </span>            :                                    std::string* merged_value);
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   // if prefix_extractor is set and bloom_bits is not 0, create prefix bloom
<span class="lineNum">     724 </span>            :   // for memtable
<span class="lineNum">     725 </span>            :   //
<span class="lineNum">     726 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     727 </span>            :   uint32_t memtable_prefix_bloom_bits;
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :   // number of hash probes per key
<span class="lineNum">     730 </span>            :   //
<span class="lineNum">     731 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     732 </span>            :   uint32_t memtable_prefix_bloom_probes;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :   // Page size for huge page TLB for bloom in memtable. If &lt;=0, not allocate
<span class="lineNum">     735 </span>            :   // from huge page TLB but from malloc.
<span class="lineNum">     736 </span>            :   // Need to reserve huge pages for it to be allocated. For example:
<span class="lineNum">     737 </span>            :   //      sysctl -w vm.nr_hugepages=20
<span class="lineNum">     738 </span>            :   // See linux doc Documentation/vm/hugetlbpage.txt
<span class="lineNum">     739 </span>            :   //
<span class="lineNum">     740 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     741 </span>            :   size_t memtable_prefix_bloom_huge_page_tlb_size;
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :   // Control locality of bloom filter probes to improve cache miss rate.
<span class="lineNum">     744 </span>            :   // This option only applies to memtable prefix bloom and plaintable
<span class="lineNum">     745 </span>            :   // prefix bloom. It essentially limits every bloom checking to one cache line.
<span class="lineNum">     746 </span>            :   // This optimization is turned off when set to 0, and positive number to turn
<span class="lineNum">     747 </span>            :   // it on.
<span class="lineNum">     748 </span>            :   // Default: 0
<span class="lineNum">     749 </span>            :   uint32_t bloom_locality;
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :   // Maximum number of successive merge operations on a key in the memtable.
<span class="lineNum">     752 </span>            :   //
<span class="lineNum">     753 </span>            :   // When a merge operation is added to the memtable and the maximum number of
<span class="lineNum">     754 </span>            :   // successive merges is reached, the value of the key will be calculated and
<span class="lineNum">     755 </span>            :   // inserted into the memtable instead of the merge operation. This will
<span class="lineNum">     756 </span>            :   // ensure that there are never more than max_successive_merges merge
<span class="lineNum">     757 </span>            :   // operations in the memtable.
<span class="lineNum">     758 </span>            :   //
<span class="lineNum">     759 </span>            :   // Default: 0 (disabled)
<span class="lineNum">     760 </span>            :   //
<span class="lineNum">     761 </span>            :   // Dynamically changeable through SetOptions() API
<span class="lineNum">     762 </span>            :   size_t max_successive_merges;
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :   // The number of partial merge operands to accumulate before partial
<span class="lineNum">     765 </span>            :   // merge will be performed. Partial merge will not be called
<span class="lineNum">     766 </span>            :   // if the list of values to merge is less than min_partial_merge_operands.
<span class="lineNum">     767 </span>            :   //
<span class="lineNum">     768 </span>            :   // If min_partial_merge_operands &lt; 2, then it will be treated as 2.
<span class="lineNum">     769 </span>            :   //
<span class="lineNum">     770 </span>            :   // Default: 2
<span class="lineNum">     771 </span>            :   uint32_t min_partial_merge_operands;
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :   // This flag specifies that the implementation should optimize the filters
<span class="lineNum">     774 </span>            :   // mainly for cases where keys are found rather than also optimize for keys
<span class="lineNum">     775 </span>            :   // missed. This would be used in cases where the application knows that
<span class="lineNum">     776 </span>            :   // there are very few misses or the performance in the case of misses is not
<span class="lineNum">     777 </span>            :   // important.
<span class="lineNum">     778 </span>            :   //
<span class="lineNum">     779 </span>            :   // For now, this flag allows us to not store filters for the last level i.e
<span class="lineNum">     780 </span>            :   // the largest level which contains data of the LSM store. For keys which
<span class="lineNum">     781 </span>            :   // are hits, the filters in this level are not useful because we will search
<span class="lineNum">     782 </span>            :   // for the data anyway. NOTE: the filters in other levels are still useful
<span class="lineNum">     783 </span>            :   // even for key hit because they tell us whether to look in that level or go
<span class="lineNum">     784 </span>            :   // to the higher level.
<span class="lineNum">     785 </span>            :   //
<span class="lineNum">     786 </span>            :   // Default: false
<span class="lineNum">     787 </span>            :   bool optimize_filters_for_hits;
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :   // After writing every SST file, reopen it and read all the keys.
<span class="lineNum">     790 </span>            :   // Default: false
<span class="lineNum">     791 </span>            :   bool paranoid_file_checks;
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :   // Measure IO stats in compactions, if true.
<span class="lineNum">     794 </span>            :   // Default: false
<span class="lineNum">     795 </span>            :   bool compaction_measure_io_stats;
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :   // Create ColumnFamilyOptions with default values for all fields
<span class="lineNum">     798 </span>            :   ColumnFamilyOptions();
<span class="lineNum">     799 </span>            :   // Create ColumnFamilyOptions from Options
<span class="lineNum">     800 </span>            :   explicit ColumnFamilyOptions(const Options&amp; options);
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :   void Dump(Logger* log) const;
<a name="803"><span class="lineNum">     803 </span>            : };</a>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineCov">       1414 : struct DBOptions {</span>
<span class="lineNum">     806 </span>            :   // The function recovers options to the option as in version 4.6.
<span class="lineNum">     807 </span>            :   DBOptions* OldDefaults(int rocksdb_major_version = 4,
<span class="lineNum">     808 </span>            :                          int rocksdb_minor_version = 6);
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :   // Some functions that make it easier to optimize RocksDB
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            : #ifndef ROCKSDB_LITE
<span class="lineNum">     813 </span>            :   // By default, RocksDB uses only one background thread for flush and
<span class="lineNum">     814 </span>            :   // compaction. Calling this function will set it up such that total of
<span class="lineNum">     815 </span>            :   // `total_threads` is used. Good value for `total_threads` is the number of
<span class="lineNum">     816 </span>            :   // cores. You almost definitely want to call this function if your system is
<span class="lineNum">     817 </span>            :   // bottlenecked by RocksDB.
<span class="lineNum">     818 </span>            :   DBOptions* IncreaseParallelism(int total_threads = 16);
<span class="lineNum">     819 </span>            : #endif  // ROCKSDB_LITE
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :   // If true, the database will be created if it is missing.
<span class="lineNum">     822 </span>            :   // Default: false
<span class="lineNum">     823 </span>            :   bool create_if_missing;
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :   // If true, missing column families will be automatically created.
<span class="lineNum">     826 </span>            :   // Default: false
<span class="lineNum">     827 </span>            :   bool create_missing_column_families;
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   // If true, an error is raised if the database already exists.
<span class="lineNum">     830 </span>            :   // Default: false
<span class="lineNum">     831 </span>            :   bool error_if_exists;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :   // If true, RocksDB will aggressively check consistency of the data.
<span class="lineNum">     834 </span>            :   // Also, if any of the  writes to the database fails (Put, Delete, Merge,
<span class="lineNum">     835 </span>            :   // Write), the database will switch to read-only mode and fail all other
<span class="lineNum">     836 </span>            :   // Write operations.
<span class="lineNum">     837 </span>            :   // In most cases you want this to be set to true.
<span class="lineNum">     838 </span>            :   // Default: true
<span class="lineNum">     839 </span>            :   bool paranoid_checks;
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :   // Use the specified object to interact with the environment,
<span class="lineNum">     842 </span>            :   // e.g. to read/write files, schedule background work, etc.
<span class="lineNum">     843 </span>            :   // Default: Env::Default()
<span class="lineNum">     844 </span>            :   Env* env;
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :   // Use to control write rate of flush and compaction. Flush has higher
<span class="lineNum">     847 </span>            :   // priority than compaction. Rate limiting is disabled if nullptr.
<span class="lineNum">     848 </span>            :   // If rate limiter is enabled, bytes_per_sync is set to 1MB by default.
<span class="lineNum">     849 </span>            :   // Default: nullptr
<span class="lineNum">     850 </span>            :   std::shared_ptr&lt;RateLimiter&gt; rate_limiter;
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :   // Use to track SST files and control their file deletion rate.
<span class="lineNum">     853 </span>            :   //
<span class="lineNum">     854 </span>            :   // Features:
<span class="lineNum">     855 </span>            :   //  - Throttle the deletion rate of the SST files.
<span class="lineNum">     856 </span>            :   //  - Keep track the total size of all SST files.
<span class="lineNum">     857 </span>            :   //  - Set a maximum allowed space limit for SST files that when reached
<span class="lineNum">     858 </span>            :   //    the DB wont do any further flushes or compactions and will set the
<span class="lineNum">     859 </span>            :   //    background error.
<span class="lineNum">     860 </span>            :   //  - Can be shared between multiple dbs.
<span class="lineNum">     861 </span>            :   // Limitations:
<span class="lineNum">     862 </span>            :   //  - Only track and throttle deletes of SST files in
<span class="lineNum">     863 </span>            :   //    first db_path (db_name if db_paths is empty).
<span class="lineNum">     864 </span>            :   //
<span class="lineNum">     865 </span>            :   // Default: nullptr
<span class="lineNum">     866 </span>            :   std::shared_ptr&lt;SstFileManager&gt; sst_file_manager;
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :   // Any internal progress/error information generated by the db will
<span class="lineNum">     869 </span>            :   // be written to info_log if it is non-nullptr, or to a file stored
<span class="lineNum">     870 </span>            :   // in the same directory as the DB contents if info_log is nullptr.
<span class="lineNum">     871 </span>            :   // Default: nullptr
<span class="lineNum">     872 </span>            :   std::shared_ptr&lt;Logger&gt; info_log;
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :   InfoLogLevel info_log_level;
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            :   // Number of open files that can be used by the DB.  You may need to
<span class="lineNum">     877 </span>            :   // increase this if your database has a large working set. Value -1 means
<span class="lineNum">     878 </span>            :   // files opened are always kept open. You can estimate number of files based
<span class="lineNum">     879 </span>            :   // on target_file_size_base and target_file_size_multiplier for level-based
<span class="lineNum">     880 </span>            :   // compaction. For universal-style compaction, you can usually set it to -1.
<span class="lineNum">     881 </span>            :   // Default: 5000 or ulimit value of max open files (whichever is smaller)
<span class="lineNum">     882 </span>            :   int max_open_files;
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            :   // If max_open_files is -1, DB will open all files on DB::Open(). You can
<span class="lineNum">     885 </span>            :   // use this option to increase the number of threads used to open the files.
<span class="lineNum">     886 </span>            :   // Default: 1
<span class="lineNum">     887 </span>            :   int max_file_opening_threads;
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   // Once write-ahead logs exceed this size, we will start forcing the flush of
<span class="lineNum">     890 </span>            :   // column families whose memtables are backed by the oldest live WAL file
<span class="lineNum">     891 </span>            :   // (i.e. the ones that are causing all the space amplification). If set to 0
<span class="lineNum">     892 </span>            :   // (default), we will dynamically choose the WAL size limit to be
<span class="lineNum">     893 </span>            :   // [sum of all write_buffer_size * max_write_buffer_number] * 4
<span class="lineNum">     894 </span>            :   // Default: 0
<span class="lineNum">     895 </span>            :   uint64_t max_total_wal_size;
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :   // If non-null, then we should collect metrics about database operations
<span class="lineNum">     898 </span>            :   // Statistics objects should not be shared between DB instances as
<span class="lineNum">     899 </span>            :   // it does not use any locks to prevent concurrent updates.
<span class="lineNum">     900 </span>            :   std::shared_ptr&lt;Statistics&gt; statistics;
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span>            :   // If true, then the contents of manifest and data files are not synced
<span class="lineNum">     903 </span>            :   // to stable storage. Their contents remain in the OS buffers till the
<span class="lineNum">     904 </span>            :   // OS decides to flush them. This option is good for bulk-loading
<span class="lineNum">     905 </span>            :   // of data. Once the bulk-loading is complete, please issue a
<span class="lineNum">     906 </span>            :   // sync to the OS to flush all dirty buffesrs to stable storage.
<span class="lineNum">     907 </span>            :   // Default: false
<span class="lineNum">     908 </span>            :   bool disableDataSync;
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :   // If true, then every store to stable storage will issue a fsync.
<span class="lineNum">     911 </span>            :   // If false, then every store to stable storage will issue a fdatasync.
<span class="lineNum">     912 </span>            :   // This parameter should be set to true while storing data to
<span class="lineNum">     913 </span>            :   // filesystem like ext3 that can lose files after a reboot.
<span class="lineNum">     914 </span>            :   // Default: false
<span class="lineNum">     915 </span>            :   bool use_fsync;
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :   // A list of paths where SST files can be put into, with its target size.
<span class="lineNum">     918 </span>            :   // Newer data is placed into paths specified earlier in the vector while
<span class="lineNum">     919 </span>            :   // older data gradually moves to paths specified later in the vector.
<span class="lineNum">     920 </span>            :   //
<span class="lineNum">     921 </span>            :   // For example, you have a flash device with 10GB allocated for the DB,
<span class="lineNum">     922 </span>            :   // as well as a hard drive of 2TB, you should config it to be:
<span class="lineNum">     923 </span>            :   //   [{&quot;/flash_path&quot;, 10GB}, {&quot;/hard_drive&quot;, 2TB}]
<span class="lineNum">     924 </span>            :   //
<span class="lineNum">     925 </span>            :   // The system will try to guarantee data under each path is close to but
<span class="lineNum">     926 </span>            :   // not larger than the target size. But current and future file sizes used
<span class="lineNum">     927 </span>            :   // by determining where to place a file are based on best-effort estimation,
<span class="lineNum">     928 </span>            :   // which means there is a chance that the actual size under the directory
<span class="lineNum">     929 </span>            :   // is slightly more than target size under some workloads. User should give
<span class="lineNum">     930 </span>            :   // some buffer room for those cases.
<span class="lineNum">     931 </span>            :   //
<span class="lineNum">     932 </span>            :   // If none of the paths has sufficient room to place a file, the file will
<span class="lineNum">     933 </span>            :   // be placed to the last path anyway, despite to the target size.
<span class="lineNum">     934 </span>            :   //
<span class="lineNum">     935 </span>            :   // Placing newer data to earlier paths is also best-efforts. User should
<span class="lineNum">     936 </span>            :   // expect user files to be placed in higher levels in some extreme cases.
<span class="lineNum">     937 </span>            :   //
<span class="lineNum">     938 </span>            :   // If left empty, only one path will be used, which is db_name passed when
<span class="lineNum">     939 </span>            :   // opening the DB.
<span class="lineNum">     940 </span>            :   // Default: empty
<span class="lineNum">     941 </span>            :   std::vector&lt;DbPath&gt; db_paths;
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            :   // This specifies the info LOG dir.
<span class="lineNum">     944 </span>            :   // If it is empty, the log files will be in the same dir as data.
<span class="lineNum">     945 </span>            :   // If it is non empty, the log files will be in the specified dir,
<span class="lineNum">     946 </span>            :   // and the db data dir's absolute path will be used as the log file
<span class="lineNum">     947 </span>            :   // name's prefix.
<span class="lineNum">     948 </span>            :   std::string db_log_dir;
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :   // This specifies the absolute dir path for write-ahead logs (WAL).
<span class="lineNum">     951 </span>            :   // If it is empty, the log files will be in the same dir as data,
<span class="lineNum">     952 </span>            :   //   dbname is used as the data dir by default
<span class="lineNum">     953 </span>            :   // If it is non empty, the log files will be in kept the specified dir.
<span class="lineNum">     954 </span>            :   // When destroying the db,
<span class="lineNum">     955 </span>            :   //   all log files in wal_dir and the dir itself is deleted
<span class="lineNum">     956 </span>            :   std::string wal_dir;
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :   // The periodicity when obsolete files get deleted. The default
<span class="lineNum">     959 </span>            :   // value is 6 hours. The files that get out of scope by compaction
<span class="lineNum">     960 </span>            :   // process will still get automatically delete on every compaction,
<span class="lineNum">     961 </span>            :   // regardless of this setting
<span class="lineNum">     962 </span>            :   uint64_t delete_obsolete_files_period_micros;
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :   // Suggested number of concurrent background compaction jobs, submitted to
<span class="lineNum">     965 </span>            :   // the default LOW priority thread pool.
<span class="lineNum">     966 </span>            :   //
<span class="lineNum">     967 </span>            :   // Default: max_background_compactions
<span class="lineNum">     968 </span>            :   int base_background_compactions;
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :   // Maximum number of concurrent background compaction jobs, submitted to
<span class="lineNum">     971 </span>            :   // the default LOW priority thread pool.
<span class="lineNum">     972 </span>            :   // We first try to schedule compactions based on
<span class="lineNum">     973 </span>            :   // `base_background_compactions`. If the compaction cannot catch up , we
<span class="lineNum">     974 </span>            :   // will increase number of compaction threads up to
<span class="lineNum">     975 </span>            :   // `max_background_compactions`.
<span class="lineNum">     976 </span>            :   //
<span class="lineNum">     977 </span>            :   // If you're increasing this, also consider increasing number of threads in
<span class="lineNum">     978 </span>            :   // LOW priority thread pool. For more information, see
<span class="lineNum">     979 </span>            :   // Env::SetBackgroundThreads
<span class="lineNum">     980 </span>            :   // Default: 1
<span class="lineNum">     981 </span>            :   int max_background_compactions;
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :   // This value represents the maximum number of threads that will
<span class="lineNum">     984 </span>            :   // concurrently perform a compaction job by breaking it into multiple,
<span class="lineNum">     985 </span>            :   // smaller ones that are run simultaneously.
<span class="lineNum">     986 </span>            :   // Default: 1 (i.e. no subcompactions)
<span class="lineNum">     987 </span>            :   uint32_t max_subcompactions;
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            :   // Maximum number of concurrent background memtable flush jobs, submitted to
<span class="lineNum">     990 </span>            :   // the HIGH priority thread pool.
<span class="lineNum">     991 </span>            :   //
<span class="lineNum">     992 </span>            :   // By default, all background jobs (major compaction and memtable flush) go
<span class="lineNum">     993 </span>            :   // to the LOW priority pool. If this option is set to a positive number,
<span class="lineNum">     994 </span>            :   // memtable flush jobs will be submitted to the HIGH priority pool.
<span class="lineNum">     995 </span>            :   // It is important when the same Env is shared by multiple db instances.
<span class="lineNum">     996 </span>            :   // Without a separate pool, long running major compaction jobs could
<span class="lineNum">     997 </span>            :   // potentially block memtable flush jobs of other db instances, leading to
<span class="lineNum">     998 </span>            :   // unnecessary Put stalls.
<span class="lineNum">     999 </span>            :   //
<span class="lineNum">    1000 </span>            :   // If you're increasing this, also consider increasing number of threads in
<span class="lineNum">    1001 </span>            :   // HIGH priority thread pool. For more information, see
<span class="lineNum">    1002 </span>            :   // Env::SetBackgroundThreads
<span class="lineNum">    1003 </span>            :   // Default: 1
<span class="lineNum">    1004 </span>            :   int max_background_flushes;
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :   // Specify the maximal size of the info log file. If the log file
<span class="lineNum">    1007 </span>            :   // is larger than `max_log_file_size`, a new info log file will
<span class="lineNum">    1008 </span>            :   // be created.
<span class="lineNum">    1009 </span>            :   // If max_log_file_size == 0, all logs will be written to one
<span class="lineNum">    1010 </span>            :   // log file.
<span class="lineNum">    1011 </span>            :   size_t max_log_file_size;
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :   // Time for the info log file to roll (in seconds).
<span class="lineNum">    1014 </span>            :   // If specified with non-zero value, log file will be rolled
<span class="lineNum">    1015 </span>            :   // if it has been active longer than `log_file_time_to_roll`.
<span class="lineNum">    1016 </span>            :   // Default: 0 (disabled)
<span class="lineNum">    1017 </span>            :   size_t log_file_time_to_roll;
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :   // Maximal info log files to be kept.
<span class="lineNum">    1020 </span>            :   // Default: 1000
<span class="lineNum">    1021 </span>            :   size_t keep_log_file_num;
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   // Recycle log files.
<span class="lineNum">    1024 </span>            :   // If non-zero, we will reuse previously written log files for new
<span class="lineNum">    1025 </span>            :   // logs, overwriting the old data.  The value indicates how many
<span class="lineNum">    1026 </span>            :   // such files we will keep around at any point in time for later
<span class="lineNum">    1027 </span>            :   // use.  This is more efficient because the blocks are already
<span class="lineNum">    1028 </span>            :   // allocated and fdatasync does not need to update the inode after
<span class="lineNum">    1029 </span>            :   // each write.
<span class="lineNum">    1030 </span>            :   // Default: 0
<span class="lineNum">    1031 </span>            :   size_t recycle_log_file_num;
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :   // manifest file is rolled over on reaching this limit.
<span class="lineNum">    1034 </span>            :   // The older manifest file be deleted.
<span class="lineNum">    1035 </span>            :   // The default value is MAX_INT so that roll-over does not take place.
<span class="lineNum">    1036 </span>            :   uint64_t max_manifest_file_size;
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :   // Number of shards used for table cache.
<span class="lineNum">    1039 </span>            :   int table_cache_numshardbits;
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :   // DEPRECATED
<span class="lineNum">    1042 </span>            :   // int table_cache_remove_scan_count_limit;
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :   // The following two fields affect how archived logs will be deleted.
<span class="lineNum">    1045 </span>            :   // 1. If both set to 0, logs will be deleted asap and will not get into
<span class="lineNum">    1046 </span>            :   //    the archive.
<span class="lineNum">    1047 </span>            :   // 2. If WAL_ttl_seconds is 0 and WAL_size_limit_MB is not 0,
<span class="lineNum">    1048 </span>            :   //    WAL files will be checked every 10 min and if total size is greater
<span class="lineNum">    1049 </span>            :   //    then WAL_size_limit_MB, they will be deleted starting with the
<span class="lineNum">    1050 </span>            :   //    earliest until size_limit is met. All empty files will be deleted.
<span class="lineNum">    1051 </span>            :   // 3. If WAL_ttl_seconds is not 0 and WAL_size_limit_MB is 0, then
<span class="lineNum">    1052 </span>            :   //    WAL files will be checked every WAL_ttl_secondsi / 2 and those that
<span class="lineNum">    1053 </span>            :   //    are older than WAL_ttl_seconds will be deleted.
<span class="lineNum">    1054 </span>            :   // 4. If both are not 0, WAL files will be checked every 10 min and both
<span class="lineNum">    1055 </span>            :   //    checks will be performed with ttl being first.
<span class="lineNum">    1056 </span>            :   uint64_t WAL_ttl_seconds;
<span class="lineNum">    1057 </span>            :   uint64_t WAL_size_limit_MB;
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :   // Number of bytes to preallocate (via fallocate) the manifest
<span class="lineNum">    1060 </span>            :   // files.  Default is 4mb, which is reasonable to reduce random IO
<span class="lineNum">    1061 </span>            :   // as well as prevent overallocation for mounts that preallocate
<span class="lineNum">    1062 </span>            :   // large amounts of data (such as xfs's allocsize option).
<span class="lineNum">    1063 </span>            :   size_t manifest_preallocation_size;
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :   // Hint the OS that it should not buffer disk I/O. Enabling this
<span class="lineNum">    1066 </span>            :   // parameter may improve performance but increases pressure on the
<span class="lineNum">    1067 </span>            :   // system cache.
<span class="lineNum">    1068 </span>            :   //
<span class="lineNum">    1069 </span>            :   // The exact behavior of this parameter is platform dependent.
<span class="lineNum">    1070 </span>            :   //
<span class="lineNum">    1071 </span>            :   // On POSIX systems, after RocksDB reads data from disk it will
<span class="lineNum">    1072 </span>            :   // mark the pages as &quot;unneeded&quot;. The operating system may - or may not
<span class="lineNum">    1073 </span>            :   // - evict these pages from memory, reducing pressure on the system
<span class="lineNum">    1074 </span>            :   // cache. If the disk block is requested again this can result in
<span class="lineNum">    1075 </span>            :   // additional disk I/O.
<span class="lineNum">    1076 </span>            :   //
<span class="lineNum">    1077 </span>            :   // On WINDOWS system, files will be opened in &quot;unbuffered I/O&quot; mode
<span class="lineNum">    1078 </span>            :   // which means that data read from the disk will not be cached or
<span class="lineNum">    1079 </span>            :   // bufferized. The hardware buffer of the devices may however still
<span class="lineNum">    1080 </span>            :   // be used. Memory mapped files are not impacted by this parameter.
<span class="lineNum">    1081 </span>            :   //
<span class="lineNum">    1082 </span>            :   // Default: true
<span class="lineNum">    1083 </span>            :   bool allow_os_buffer;
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :   // Allow the OS to mmap file for reading sst tables. Default: false
<span class="lineNum">    1086 </span>            :   bool allow_mmap_reads;
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :   // Allow the OS to mmap file for writing.
<span class="lineNum">    1089 </span>            :   // DB::SyncWAL() only works if this is set to false.
<span class="lineNum">    1090 </span>            :   // Default: false
<span class="lineNum">    1091 </span>            :   bool allow_mmap_writes;
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :   // If false, fallocate() calls are bypassed
<span class="lineNum">    1094 </span>            :   bool allow_fallocate;
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   // Disable child process inherit open files. Default: true
<span class="lineNum">    1097 </span>            :   bool is_fd_close_on_exec;
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :   // DEPRECATED -- this options is no longer used
<span class="lineNum">    1100 </span>            :   bool skip_log_error_on_recovery;
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :   // if not zero, dump rocksdb.stats to LOG every stats_dump_period_sec
<span class="lineNum">    1103 </span>            :   // Default: 600 (10 min)
<span class="lineNum">    1104 </span>            :   unsigned int stats_dump_period_sec;
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            :   // If set true, will hint the underlying file system that the file
<span class="lineNum">    1107 </span>            :   // access pattern is random, when a sst file is opened.
<span class="lineNum">    1108 </span>            :   // Default: true
<span class="lineNum">    1109 </span>            :   bool advise_random_on_open;
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :   // Amount of data to build up in memtables across all column
<span class="lineNum">    1112 </span>            :   // families before writing to disk.
<span class="lineNum">    1113 </span>            :   //
<span class="lineNum">    1114 </span>            :   // This is distinct from write_buffer_size, which enforces a limit
<span class="lineNum">    1115 </span>            :   // for a single memtable.
<span class="lineNum">    1116 </span>            :   //
<span class="lineNum">    1117 </span>            :   // This feature is disabled by default. Specify a non-zero value
<span class="lineNum">    1118 </span>            :   // to enable it.
<span class="lineNum">    1119 </span>            :   //
<span class="lineNum">    1120 </span>            :   // Default: 0 (disabled)
<span class="lineNum">    1121 </span>            :   size_t db_write_buffer_size;
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :   // Specify the file access pattern once a compaction is started.
<span class="lineNum">    1124 </span>            :   // It will be applied to all input files of a compaction.
<span class="lineNum">    1125 </span>            :   // Default: NORMAL
<span class="lineNum">    1126 </span>            :   enum AccessHint {
<span class="lineNum">    1127 </span>            :       NONE,
<span class="lineNum">    1128 </span>            :       NORMAL,
<span class="lineNum">    1129 </span>            :       SEQUENTIAL,
<span class="lineNum">    1130 </span>            :       WILLNEED
<span class="lineNum">    1131 </span>            :   };
<span class="lineNum">    1132 </span>            :   AccessHint access_hint_on_compaction_start;
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            :   // If true, always create a new file descriptor and new table reader
<span class="lineNum">    1135 </span>            :   // for compaction inputs. Turn this parameter on may introduce extra
<span class="lineNum">    1136 </span>            :   // memory usage in the table reader, if it allocates extra memory
<span class="lineNum">    1137 </span>            :   // for indexes. This will allow file descriptor prefetch options
<span class="lineNum">    1138 </span>            :   // to be set for compaction input files and not to impact file
<span class="lineNum">    1139 </span>            :   // descriptors for the same file used by user queries.
<span class="lineNum">    1140 </span>            :   // Suggest to enable BlockBasedTableOptions.cache_index_and_filter_blocks
<span class="lineNum">    1141 </span>            :   // for this mode if using block-based table.
<span class="lineNum">    1142 </span>            :   //
<span class="lineNum">    1143 </span>            :   // Default: false
<span class="lineNum">    1144 </span>            :   bool new_table_reader_for_compaction_inputs;
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :   // If non-zero, we perform bigger reads when doing compaction. If you're
<span class="lineNum">    1147 </span>            :   // running RocksDB on spinning disks, you should set this to at least 2MB.
<span class="lineNum">    1148 </span>            :   // That way RocksDB's compaction is doing sequential instead of random reads.
<span class="lineNum">    1149 </span>            :   //
<span class="lineNum">    1150 </span>            :   // When non-zero, we also force new_table_reader_for_compaction_inputs to
<span class="lineNum">    1151 </span>            :   // true.
<span class="lineNum">    1152 </span>            :   //
<span class="lineNum">    1153 </span>            :   // Default: 0
<span class="lineNum">    1154 </span>            :   size_t compaction_readahead_size;
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            :   // This is a maximum buffer size that is used by WinMmapReadableFile in
<span class="lineNum">    1157 </span>            :   // unbuffered disk I/O mode. We need to maintain an aligned buffer for
<span class="lineNum">    1158 </span>            :   // reads. We allow the buffer to grow until the specified value and then
<span class="lineNum">    1159 </span>            :   // for bigger requests allocate one shot buffers. In unbuffered mode we
<span class="lineNum">    1160 </span>            :   // always bypass read-ahead buffer at ReadaheadRandomAccessFile
<span class="lineNum">    1161 </span>            :   // When read-ahead is required we then make use of compaction_readahead_size
<span class="lineNum">    1162 </span>            :   // value and always try to read ahead. With read-ahead we always
<span class="lineNum">    1163 </span>            :   // pre-allocate buffer to the size instead of growing it up to a limit.
<span class="lineNum">    1164 </span>            :   //
<span class="lineNum">    1165 </span>            :   // This option is currently honored only on Windows
<span class="lineNum">    1166 </span>            :   //
<span class="lineNum">    1167 </span>            :   // Default: 1 Mb
<span class="lineNum">    1168 </span>            :   //
<span class="lineNum">    1169 </span>            :   // Special value: 0 - means do not maintain per instance buffer. Allocate
<span class="lineNum">    1170 </span>            :   //                per request buffer and avoid locking.
<span class="lineNum">    1171 </span>            :   size_t random_access_max_buffer_size;
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :   // This is the maximum buffer size that is used by WritableFileWriter.
<span class="lineNum">    1174 </span>            :   // On Windows, we need to maintain an aligned buffer for writes.
<span class="lineNum">    1175 </span>            :   // We allow the buffer to grow until it's size hits the limit.
<span class="lineNum">    1176 </span>            :   //
<span class="lineNum">    1177 </span>            :   // Default: 1024 * 1024 (1 MB)
<span class="lineNum">    1178 </span>            :   size_t writable_file_max_buffer_size;
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            :   // Use adaptive mutex, which spins in the user space before resorting
<span class="lineNum">    1182 </span>            :   // to kernel. This could reduce context switch when the mutex is not
<span class="lineNum">    1183 </span>            :   // heavily contended. However, if the mutex is hot, we could end up
<span class="lineNum">    1184 </span>            :   // wasting spin time.
<span class="lineNum">    1185 </span>            :   // Default: false
<span class="lineNum">    1186 </span>            :   bool use_adaptive_mutex;
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :   // Create DBOptions with default values for all fields
<span class="lineNum">    1189 </span>            :   DBOptions();
<span class="lineNum">    1190 </span>            :   // Create DBOptions from Options
<span class="lineNum">    1191 </span>            :   explicit DBOptions(const Options&amp; options);
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :   void Dump(Logger* log) const;
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            :   // Allows OS to incrementally sync files to disk while they are being
<span class="lineNum">    1196 </span>            :   // written, asynchronously, in the background. This operation can be used
<span class="lineNum">    1197 </span>            :   // to smooth out write I/Os over time. Users shouldn't reply on it for
<span class="lineNum">    1198 </span>            :   // persistency guarantee.
<span class="lineNum">    1199 </span>            :   // Issue one request for every bytes_per_sync written. 0 turns it off.
<span class="lineNum">    1200 </span>            :   // Default: 0
<span class="lineNum">    1201 </span>            :   //
<span class="lineNum">    1202 </span>            :   // You may consider using rate_limiter to regulate write rate to device.
<span class="lineNum">    1203 </span>            :   // When rate limiter is enabled, it automatically enables bytes_per_sync
<span class="lineNum">    1204 </span>            :   // to 1MB.
<span class="lineNum">    1205 </span>            :   //
<span class="lineNum">    1206 </span>            :   // This option applies to table files
<span class="lineNum">    1207 </span>            :   uint64_t bytes_per_sync;
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            :   // Same as bytes_per_sync, but applies to WAL files
<span class="lineNum">    1210 </span>            :   // Default: 0, turned off
<span class="lineNum">    1211 </span>            :   uint64_t wal_bytes_per_sync;
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            :   // A vector of EventListeners which call-back functions will be called
<span class="lineNum">    1214 </span>            :   // when specific RocksDB event happens.
<span class="lineNum">    1215 </span>            :   std::vector&lt;std::shared_ptr&lt;EventListener&gt;&gt; listeners;
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            :   // If true, then the status of the threads involved in this DB will
<span class="lineNum">    1218 </span>            :   // be tracked and available via GetThreadList() API.
<span class="lineNum">    1219 </span>            :   //
<span class="lineNum">    1220 </span>            :   // Default: false
<span class="lineNum">    1221 </span>            :   bool enable_thread_tracking;
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            :   // The limited write rate to DB if soft_pending_compaction_bytes_limit or
<span class="lineNum">    1224 </span>            :   // level0_slowdown_writes_trigger is triggered, or we are writing to the
<span class="lineNum">    1225 </span>            :   // last mem table allowed and we allow more than 3 mem tables. It is
<span class="lineNum">    1226 </span>            :   // calculated using size of user write requests before compression.
<span class="lineNum">    1227 </span>            :   // RocksDB may decide to slow down more if the compaction still
<span class="lineNum">    1228 </span>            :   // gets behind further.
<span class="lineNum">    1229 </span>            :   // Unit: byte per second.
<span class="lineNum">    1230 </span>            :   //
<span class="lineNum">    1231 </span>            :   // Default: 2MB/s
<span class="lineNum">    1232 </span>            :   uint64_t delayed_write_rate;
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :   // If true, allow multi-writers to update mem tables in parallel.
<span class="lineNum">    1235 </span>            :   // Only some memtable_factory-s support concurrent writes; currently it
<span class="lineNum">    1236 </span>            :   // is implemented only for SkipListFactory.  Concurrent memtable writes
<span class="lineNum">    1237 </span>            :   // are not compatible with inplace_update_support or filter_deletes.
<span class="lineNum">    1238 </span>            :   // It is strongly recommended to set enable_write_thread_adaptive_yield
<span class="lineNum">    1239 </span>            :   // if you are going to use this feature.
<span class="lineNum">    1240 </span>            :   //
<span class="lineNum">    1241 </span>            :   // THIS FEATURE IS NOT STABLE YET.
<span class="lineNum">    1242 </span>            :   //
<span class="lineNum">    1243 </span>            :   // Default: false
<span class="lineNum">    1244 </span>            :   bool allow_concurrent_memtable_write;
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :   // If true, threads synchronizing with the write batch group leader will
<span class="lineNum">    1247 </span>            :   // wait for up to write_thread_max_yield_usec before blocking on a mutex.
<span class="lineNum">    1248 </span>            :   // This can substantially improve throughput for concurrent workloads,
<span class="lineNum">    1249 </span>            :   // regardless of whether allow_concurrent_memtable_write is enabled.
<span class="lineNum">    1250 </span>            :   //
<span class="lineNum">    1251 </span>            :   // THIS FEATURE IS NOT STABLE YET.
<span class="lineNum">    1252 </span>            :   //
<span class="lineNum">    1253 </span>            :   // Default: false
<span class="lineNum">    1254 </span>            :   bool enable_write_thread_adaptive_yield;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :   // The maximum number of microseconds that a write operation will use
<span class="lineNum">    1257 </span>            :   // a yielding spin loop to coordinate with other write threads before
<span class="lineNum">    1258 </span>            :   // blocking on a mutex.  (Assuming write_thread_slow_yield_usec is
<span class="lineNum">    1259 </span>            :   // set properly) increasing this value is likely to increase RocksDB
<span class="lineNum">    1260 </span>            :   // throughput at the expense of increased CPU usage.
<span class="lineNum">    1261 </span>            :   //
<span class="lineNum">    1262 </span>            :   // Default: 100
<span class="lineNum">    1263 </span>            :   uint64_t write_thread_max_yield_usec;
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :   // The latency in microseconds after which a std::this_thread::yield
<span class="lineNum">    1266 </span>            :   // call (sched_yield on Linux) is considered to be a signal that
<span class="lineNum">    1267 </span>            :   // other processes or threads would like to use the current core.
<span class="lineNum">    1268 </span>            :   // Increasing this makes writer threads more likely to take CPU
<span class="lineNum">    1269 </span>            :   // by spinning, which will show up as an increase in the number of
<span class="lineNum">    1270 </span>            :   // involuntary context switches.
<span class="lineNum">    1271 </span>            :   //
<span class="lineNum">    1272 </span>            :   // Default: 3
<span class="lineNum">    1273 </span>            :   uint64_t write_thread_slow_yield_usec;
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            :   // If true, then DB::Open() will not update the statistics used to optimize
<span class="lineNum">    1276 </span>            :   // compaction decision by loading table properties from many files.
<span class="lineNum">    1277 </span>            :   // Turning off this feature will improve DBOpen time especially in
<span class="lineNum">    1278 </span>            :   // disk environment.
<span class="lineNum">    1279 </span>            :   //
<span class="lineNum">    1280 </span>            :   // Default: false
<span class="lineNum">    1281 </span>            :   bool skip_stats_update_on_db_open;
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :   // Recovery mode to control the consistency while replaying WAL
<span class="lineNum">    1284 </span>            :   // Default: kTolerateCorruptedTailRecords
<span class="lineNum">    1285 </span>            :   WALRecoveryMode wal_recovery_mode;
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :   // A global cache for table-level rows.
<span class="lineNum">    1288 </span>            :   // Default: nullptr (disabled)
<span class="lineNum">    1289 </span>            :   // Not supported in ROCKSDB_LITE mode!
<span class="lineNum">    1290 </span>            :   std::shared_ptr&lt;Cache&gt; row_cache;
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span>            : #ifndef ROCKSDB_LITE
<span class="lineNum">    1293 </span>            :   // A filter object supplied to be invoked while processing write-ahead-logs
<span class="lineNum">    1294 </span>            :   // (WALs) during recovery. The filter provides a way to inspect log
<span class="lineNum">    1295 </span>            :   // records, ignoring a particular record or skipping replay.
<span class="lineNum">    1296 </span>            :   // The filter is invoked at startup and is invoked from a single-thread
<span class="lineNum">    1297 </span>            :   // currently.
<span class="lineNum">    1298 </span>            :   WalFilter* wal_filter;
<span class="lineNum">    1299 </span>            : #endif  // ROCKSDB_LITE
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :   // If true, then DB::Open / CreateColumnFamily / DropColumnFamily
<span class="lineNum">    1302 </span>            :   // / SetOptions will fail if options file is not detected or properly
<span class="lineNum">    1303 </span>            :   // persisted.
<span class="lineNum">    1304 </span>            :   //
<span class="lineNum">    1305 </span>            :   // DEFAULT: false
<span class="lineNum">    1306 </span>            :   bool fail_if_options_file_error;
<span class="lineNum">    1307 </span>            : };
<a name="1308"><span class="lineNum">    1308 </span>            : </a>
<span class="lineNum">    1309 </span>            : // Options to control the behavior of a database (passed to DB::Open)
<a name="1310"><span class="lineNum">    1310 </span><span class="lineCov">        202 : struct Options : public DBOptions, public ColumnFamilyOptions {</span></a>
<span class="lineNum">    1311 </span>            :   // Create an Options object with default values for all fields.
<span class="lineNum">    1312 </span><span class="lineCov">        202 :   Options() : DBOptions(), ColumnFamilyOptions() {}</span>
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            :   Options(const DBOptions&amp; db_options,
<span class="lineNum">    1315 </span>            :           const ColumnFamilyOptions&amp; column_family_options)
<span class="lineNum">    1316 </span>            :       : DBOptions(db_options), ColumnFamilyOptions(column_family_options) {}
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            :   // The function recovers options to the option as in version 4.6.
<span class="lineNum">    1319 </span>            :   Options* OldDefaults(int rocksdb_major_version = 4,
<span class="lineNum">    1320 </span>            :                        int rocksdb_minor_version = 6);
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :   void Dump(Logger* log) const;
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            :   void DumpCFOptions(Logger* log) const;
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            :   // Set appropriate parameters for bulk loading.
<span class="lineNum">    1327 </span>            :   // The reason that this is a function that returns &quot;this&quot; instead of a
<span class="lineNum">    1328 </span>            :   // constructor is to enable chaining of multiple similar calls in the future.
<span class="lineNum">    1329 </span>            :   //
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            :   // All data will be in level 0 without any automatic compaction.
<span class="lineNum">    1332 </span>            :   // It's recommended to manually call CompactRange(NULL, NULL) before reading
<span class="lineNum">    1333 </span>            :   // from the database, because otherwise the read can be very slow.
<span class="lineNum">    1334 </span>            :   Options* PrepareForBulkLoad();
<span class="lineNum">    1335 </span>            : };
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            : //
<span class="lineNum">    1338 </span>            : // An application can issue a read request (via Get/Iterators) and specify
<span class="lineNum">    1339 </span>            : // if that read should process data that ALREADY resides on a specified cache
<span class="lineNum">    1340 </span>            : // level. For example, if an application specifies kBlockCacheTier then the
<span class="lineNum">    1341 </span>            : // Get call will process data that is already processed in the memtable or
<span class="lineNum">    1342 </span>            : // the block cache. It will not page in data from the OS cache or data that
<span class="lineNum">    1343 </span>            : // resides in storage.
<span class="lineNum">    1344 </span>            : enum ReadTier {
<span class="lineNum">    1345 </span>            :   kReadAllTier = 0x0,     // data in memtable, block cache, OS cache or storage
<span class="lineNum">    1346 </span>            :   kBlockCacheTier = 0x1,  // data in memtable or block cache
<span class="lineNum">    1347 </span>            :   kPersistedTier = 0x2    // persisted data.  When WAL is disabled, this option
<span class="lineNum">    1348 </span>            :                           // will skip data in memtable.
<span class="lineNum">    1349 </span>            :                           // Note that this ReadTier currently only supports
<span class="lineNum">    1350 </span>            :                           // Get and MultiGet and does not support iterators.
<span class="lineNum">    1351 </span>            : };
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            : // Options that control read operations
<span class="lineNum">    1354 </span>            : struct ReadOptions {
<span class="lineNum">    1355 </span>            :   // If true, all data read from underlying storage will be
<span class="lineNum">    1356 </span>            :   // verified against corresponding checksums.
<span class="lineNum">    1357 </span>            :   // Default: true
<span class="lineNum">    1358 </span>            :   bool verify_checksums;
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span>            :   // Should the &quot;data block&quot;/&quot;index block&quot;/&quot;filter block&quot; read for this
<span class="lineNum">    1361 </span>            :   // iteration be cached in memory?
<span class="lineNum">    1362 </span>            :   // Callers may wish to set this field to false for bulk scans.
<span class="lineNum">    1363 </span>            :   // Default: true
<span class="lineNum">    1364 </span>            :   bool fill_cache;
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :   // If this option is set and memtable implementation allows, Seek
<span class="lineNum">    1367 </span>            :   // might only return keys with the same prefix as the seek-key
<span class="lineNum">    1368 </span>            :   //
<span class="lineNum">    1369 </span>            :   // ! DEPRECATED: prefix_seek is on by default when prefix_extractor
<span class="lineNum">    1370 </span>            :   // is configured
<span class="lineNum">    1371 </span>            :   // bool prefix_seek;
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :   // If &quot;snapshot&quot; is non-nullptr, read as of the supplied snapshot
<span class="lineNum">    1374 </span>            :   // (which must belong to the DB that is being read and which must
<span class="lineNum">    1375 </span>            :   // not have been released).  If &quot;snapshot&quot; is nullptr, use an impliicit
<span class="lineNum">    1376 </span>            :   // snapshot of the state at the beginning of this read operation.
<span class="lineNum">    1377 </span>            :   // Default: nullptr
<span class="lineNum">    1378 </span>            :   const Snapshot* snapshot;
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            :   // If &quot;prefix&quot; is non-nullptr, and ReadOptions is being passed to
<span class="lineNum">    1381 </span>            :   // db.NewIterator, only return results when the key begins with this
<span class="lineNum">    1382 </span>            :   // prefix.  This field is ignored by other calls (e.g., Get).
<span class="lineNum">    1383 </span>            :   // Options.prefix_extractor must also be set, and
<span class="lineNum">    1384 </span>            :   // prefix_extractor.InRange(prefix) must be true.  The iterator
<span class="lineNum">    1385 </span>            :   // returned by NewIterator when this option is set will behave just
<span class="lineNum">    1386 </span>            :   // as if the underlying store did not contain any non-matching keys,
<span class="lineNum">    1387 </span>            :   // with two exceptions.  Seek() only accepts keys starting with the
<span class="lineNum">    1388 </span>            :   // prefix, and SeekToLast() is not supported.  prefix filter with this
<span class="lineNum">    1389 </span>            :   // option will sometimes reduce the number of read IOPs.
<span class="lineNum">    1390 </span>            :   // Default: nullptr
<span class="lineNum">    1391 </span>            :   //
<span class="lineNum">    1392 </span>            :   // ! DEPRECATED
<span class="lineNum">    1393 </span>            :   // const Slice* prefix;
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :   // &quot;iterate_upper_bound&quot; defines the extent upto which the forward iterator
<span class="lineNum">    1396 </span>            :   // can returns entries. Once the bound is reached, Valid() will be false.
<span class="lineNum">    1397 </span>            :   // &quot;iterate_upper_bound&quot; is exclusive ie the bound value is
<span class="lineNum">    1398 </span>            :   // not a valid entry.  If iterator_extractor is not null, the Seek target
<span class="lineNum">    1399 </span>            :   // and iterator_upper_bound need to have the same prefix.
<span class="lineNum">    1400 </span>            :   // This is because ordering is not guaranteed outside of prefix domain.
<span class="lineNum">    1401 </span>            :   // There is no lower bound on the iterator. If needed, that can be easily
<span class="lineNum">    1402 </span>            :   // implemented
<span class="lineNum">    1403 </span>            :   //
<span class="lineNum">    1404 </span>            :   // Default: nullptr
<span class="lineNum">    1405 </span>            :   const Slice* iterate_upper_bound;
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            :   // Specify if this read request should process data that ALREADY
<span class="lineNum">    1408 </span>            :   // resides on a particular cache. If the required data is not
<span class="lineNum">    1409 </span>            :   // found at the specified cache, then Status::Incomplete is returned.
<span class="lineNum">    1410 </span>            :   // Default: kReadAllTier
<span class="lineNum">    1411 </span>            :   ReadTier read_tier;
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span>            :   // Specify to create a tailing iterator -- a special iterator that has a
<span class="lineNum">    1414 </span>            :   // view of the complete database (i.e. it can also be used to read newly
<span class="lineNum">    1415 </span>            :   // added data) and is optimized for sequential reads. It will return records
<span class="lineNum">    1416 </span>            :   // that were inserted into the database after the creation of the iterator.
<span class="lineNum">    1417 </span>            :   // Default: false
<span class="lineNum">    1418 </span>            :   // Not supported in ROCKSDB_LITE mode!
<span class="lineNum">    1419 </span>            :   bool tailing;
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span>            :   // Specify to create a managed iterator -- a special iterator that
<span class="lineNum">    1422 </span>            :   // uses less resources by having the ability to free its underlying
<span class="lineNum">    1423 </span>            :   // resources on request.
<span class="lineNum">    1424 </span>            :   // Default: false
<span class="lineNum">    1425 </span>            :   // Not supported in ROCKSDB_LITE mode!
<span class="lineNum">    1426 </span>            :   bool managed;
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            :   // Enable a total order seek regardless of index format (e.g. hash index)
<span class="lineNum">    1429 </span>            :   // used in the table. Some table format (e.g. plain table) may not support
<span class="lineNum">    1430 </span>            :   // this option.
<span class="lineNum">    1431 </span>            :   bool total_order_seek;
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :   // Enforce that the iterator only iterates over the same prefix as the seek.
<span class="lineNum">    1434 </span>            :   // This option is effective only for prefix seeks, i.e. prefix_extractor is
<span class="lineNum">    1435 </span>            :   // non-null for the column family and total_order_seek is false.  Unlike
<span class="lineNum">    1436 </span>            :   // iterate_upper_bound, prefix_same_as_start only works within a prefix
<span class="lineNum">    1437 </span>            :   // but in both directions.
<span class="lineNum">    1438 </span>            :   // Default: false
<span class="lineNum">    1439 </span>            :   bool prefix_same_as_start;
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :   // Keep the blocks loaded by the iterator pinned in memory as long as the
<span class="lineNum">    1442 </span>            :   // iterator is not deleted, If used when reading from tables created with
<span class="lineNum">    1443 </span>            :   // BlockBasedTableOptions::use_delta_encoding = false,
<span class="lineNum">    1444 </span>            :   // Iterator's property &quot;rocksdb.iterator.is-key-pinned&quot; is guaranteed to
<span class="lineNum">    1445 </span>            :   // return 1.
<span class="lineNum">    1446 </span>            :   // Default: false
<span class="lineNum">    1447 </span>            :   bool pin_data;
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            :   ReadOptions();
<span class="lineNum">    1450 </span>            :   ReadOptions(bool cksum, bool cache);
<span class="lineNum">    1451 </span>            : };
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span>            : // Options that control write operations
<span class="lineNum">    1454 </span>            : struct WriteOptions {
<span class="lineNum">    1455 </span>            :   // If true, the write will be flushed from the operating system
<span class="lineNum">    1456 </span>            :   // buffer cache (by calling WritableFile::Sync()) before the write
<span class="lineNum">    1457 </span>            :   // is considered complete.  If this flag is true, writes will be
<span class="lineNum">    1458 </span>            :   // slower.
<span class="lineNum">    1459 </span>            :   //
<span class="lineNum">    1460 </span>            :   // If this flag is false, and the machine crashes, some recent
<span class="lineNum">    1461 </span>            :   // writes may be lost.  Note that if it is just the process that
<span class="lineNum">    1462 </span>            :   // crashes (i.e., the machine does not reboot), no writes will be
<span class="lineNum">    1463 </span>            :   // lost even if sync==false.
<span class="lineNum">    1464 </span>            :   //
<span class="lineNum">    1465 </span>            :   // In other words, a DB write with sync==false has similar
<span class="lineNum">    1466 </span>            :   // crash semantics as the &quot;write()&quot; system call.  A DB write
<span class="lineNum">    1467 </span>            :   // with sync==true has similar crash semantics to a &quot;write()&quot;
<span class="lineNum">    1468 </span>            :   // system call followed by &quot;fdatasync()&quot;.
<span class="lineNum">    1469 </span>            :   //
<span class="lineNum">    1470 </span>            :   // Default: false
<span class="lineNum">    1471 </span>            :   bool sync;
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :   // If true, writes will not first go to the write ahead log,
<span class="lineNum">    1474 </span>            :   // and the write may got lost after a crash.
<span class="lineNum">    1475 </span>            :   bool disableWAL;
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            :   // The option is deprecated. It's not used anymore.
<span class="lineNum">    1478 </span>            :   uint64_t timeout_hint_us;
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :   // If true and if user is trying to write to column families that don't exist
<span class="lineNum">    1481 </span>            :   // (they were dropped),  ignore the write (don't return an error). If there
<span class="lineNum">    1482 </span>            :   // are multiple writes in a WriteBatch, other writes will succeed.
<span class="lineNum">    1483 </span>            :   // Default: false
<a name="1484"><span class="lineNum">    1484 </span>            :   bool ignore_missing_column_families;</a>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineCov">        300 :   WriteOptions()</span>
<span class="lineNum">    1487 </span>            :       : sync(false),
<span class="lineNum">    1488 </span>            :         disableWAL(false),
<span class="lineNum">    1489 </span>            :         timeout_hint_us(0),
<span class="lineNum">    1490 </span><span class="lineCov">        300 :         ignore_missing_column_families(false) {}</span>
<span class="lineNum">    1491 </span>            : };
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            : // Options that control flush operations
<span class="lineNum">    1494 </span>            : struct FlushOptions {
<span class="lineNum">    1495 </span>            :   // If true, the flush will wait until the flush is done.
<span class="lineNum">    1496 </span>            :   // Default: true
<span class="lineNum">    1497 </span>            :   bool wait;
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            :   FlushOptions() : wait(true) {}
<span class="lineNum">    1500 </span>            : };
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            : // Get options based on some guidelines. Now only tune parameter based on
<span class="lineNum">    1503 </span>            : // flush/compaction and fill default parameters for other parameters.
<span class="lineNum">    1504 </span>            : // total_write_buffer_limit: budget for memory spent for mem tables
<span class="lineNum">    1505 </span>            : // read_amplification_threshold: comfortable value of read amplification
<span class="lineNum">    1506 </span>            : // write_amplification_threshold: comfortable value of write amplification.
<span class="lineNum">    1507 </span>            : // target_db_size: estimated total DB size.
<span class="lineNum">    1508 </span>            : extern Options GetOptions(size_t total_write_buffer_limit,
<span class="lineNum">    1509 </span>            :                           int read_amplification_threshold = 8,
<span class="lineNum">    1510 </span>            :                           int write_amplification_threshold = 32,
<span class="lineNum">    1511 </span>            :                           uint64_t target_db_size = 68719476736 /* 64GB */);
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : // Create a Logger from provided DBOptions
<span class="lineNum">    1514 </span>            : extern Status CreateLoggerFromOptions(const std::string&amp; dbname,
<span class="lineNum">    1515 </span>            :                                       const DBOptions&amp; options,
<span class="lineNum">    1516 </span>            :                                       std::shared_ptr&lt;Logger&gt;* logger);
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span>            : // CompactionOptions are used in CompactFiles() call.
<span class="lineNum">    1519 </span>            : struct CompactionOptions {
<span class="lineNum">    1520 </span>            :   // Compaction output compression type
<span class="lineNum">    1521 </span>            :   // Default: snappy
<span class="lineNum">    1522 </span>            :   CompressionType compression;
<span class="lineNum">    1523 </span>            :   // Compaction will create files of size `output_file_size_limit`.
<span class="lineNum">    1524 </span>            :   // Default: MAX, which means that compaction will create a single file
<span class="lineNum">    1525 </span>            :   uint64_t output_file_size_limit;
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span>            :   CompactionOptions()
<span class="lineNum">    1528 </span>            :       : compression(kSnappyCompression),
<span class="lineNum">    1529 </span>            :         output_file_size_limit(std::numeric_limits&lt;uint64_t&gt;::max()) {}
<span class="lineNum">    1530 </span>            : };
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            : // For level based compaction, we can configure if we want to skip/force
<span class="lineNum">    1533 </span>            : // bottommost level compaction.
<span class="lineNum">    1534 </span>            : enum class BottommostLevelCompaction {
<span class="lineNum">    1535 </span>            :   // Skip bottommost level compaction
<span class="lineNum">    1536 </span>            :   kSkip,
<span class="lineNum">    1537 </span>            :   // Only compact bottommost level if there is a compaction filter
<span class="lineNum">    1538 </span>            :   // This is the default option
<span class="lineNum">    1539 </span>            :   kIfHaveCompactionFilter,
<span class="lineNum">    1540 </span>            :   // Always compact bottommost level
<span class="lineNum">    1541 </span>            :   kForce,
<span class="lineNum">    1542 </span>            : };
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span>            : // CompactRangeOptions is used by CompactRange() call.
<span class="lineNum">    1545 </span>            : struct CompactRangeOptions {
<span class="lineNum">    1546 </span>            :   // If true, no other compaction will run at the same time as this
<span class="lineNum">    1547 </span>            :   // manual compaction
<span class="lineNum">    1548 </span>            :   bool exclusive_manual_compaction = true;
<span class="lineNum">    1549 </span>            :   // If true, compacted files will be moved to the minimum level capable
<span class="lineNum">    1550 </span>            :   // of holding the data or given level (specified non-negative target_level).
<span class="lineNum">    1551 </span>            :   bool change_level = false;
<span class="lineNum">    1552 </span>            :   // If change_level is true and target_level have non-negative value, compacted
<span class="lineNum">    1553 </span>            :   // files will be moved to target_level.
<span class="lineNum">    1554 </span>            :   int target_level = -1;
<span class="lineNum">    1555 </span>            :   // Compaction outputs will be placed in options.db_paths[target_path_id].
<span class="lineNum">    1556 </span>            :   // Behavior is undefined if target_path_id is out of range.
<span class="lineNum">    1557 </span>            :   uint32_t target_path_id = 0;
<span class="lineNum">    1558 </span>            :   // By default level based compaction will only compact the bottommost level
<span class="lineNum">    1559 </span>            :   // if there is a compaction filter
<span class="lineNum">    1560 </span>            :   BottommostLevelCompaction bottommost_level_compaction =
<span class="lineNum">    1561 </span>            :       BottommostLevelCompaction::kIfHaveCompactionFilter;
<span class="lineNum">    1562 </span>            : };
<span class="lineNum">    1563 </span>            : }  // namespace rocksdb
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span>            : #endif  // STORAGE_ROCKSDB_INCLUDE_OPTIONS_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
